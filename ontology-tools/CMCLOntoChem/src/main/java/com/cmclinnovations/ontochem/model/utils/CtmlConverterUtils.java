package com.cmclinnovations.ontochem.model.utils;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;

import org.semanticweb.owlapi.model.IRI;
import org.semanticweb.owlapi.model.OWLOntology;
import org.semanticweb.owlapi.model.OWLOntologyCreationException;
import org.semanticweb.owlapi.model.OWLOntologyManager;
import org.semanticweb.owlapi.reasoner.OWLReasoner;
import org.semanticweb.owlapi.reasoner.structural.StructuralReasonerFactory;
import org.slf4j.Logger;

import com.cmclinnovations.ontochem.model.converter.ctml.CtmlConverter;
import com.cmclinnovations.ontochem.model.exception.OntoException;

import de.derivo.sparqldlapi.QueryEngine;

/**
 * A utility class that supports the following functionalities:<p>
 * 1. Helps convert a file system path to a URL.
 * In particular, it supports the following string conversion features:</p>
 * a) the replacement of each single space (' ') of a path with an underscore ('_').</br>
 * b) the replacement of each backslash with a front slash.</br>
 * c) the addition of the protocol 'file:/' at the beginning of a path.</br>
 * d) the extraction of a mechanism name from a file path.</br>
 * e) the formation of a URL, suitable to be used in an OWL file, by combining
 * a file path and name.</p>
 * 2. Splits a space separated string and put each split part as a key and
 * the in
 * a Hashmap and 
 * 
 * 
 * @author Feroz Farazi (msff2@cam.ac.uk)
 *
 */
public class CtmlConverterUtils extends CtmlConverter{
	
	static Logger logger = org.slf4j.LoggerFactory.getLogger(CtmlConverterUtils.class);
	/**
	 * Replaces each space character of a path
	 * with an underscore.
	 * 
	 * @param path a path that is being processed to get
	 * spaces replaced by underscores.
	 * 
	 * @return a URL generated by replacing spaces with underscores
	 * @throws OntoException a specialised exception designed to deal with
	 * ontology to ctml and ctml to ontology generation related errors
	 */
	public static String convertToURLString(String path) throws OntoException{
		String urlString ="";
		if(path!=null){
			urlString = path.replace(' ', '_');
		} else{
			logger.error("The input path is null.");
			throw new OntoException("A null input path has been provided.");
		}
		return urlString;
	}
	
	/**
	 * Replaces each backslash of a path with a front slash to
	 * make it suitable to be used as a URL.
	 * 
	 * @param path a path that is being converted to a URL
	 * @return a URL after replacing the backslashes with the front.
	 * slashes.
	 * @throws OntoException a specialised exception designed to deal with
	 * ontology to ctml and ctml to ontology generation related errors.
	 */
	public static String formatToURLSlash(String path) throws OntoException{
		if(path==null){
			logger.error("The input path is null.");
			throw new OntoException("A null input path has been provided.");
		}
		if(path.contains("\\")){
			path = path.replace("\\", "/");
		}
		return path;
	}

	/**
	 * Adds the protocol 'file:/' at the beginning of a file path
	 * to form a URL that can be used in an OWL file as a URL.
	 * 
	 * @param path an absolute file path that needs to be converted
	 * to a URL that can be used in an OWL file.
	 * @return an OWL file formatted URL.
	 * @throws OntoException a specialised exception designed to deal with
	 * ontology to ctml and ctml to ontology generation related errors.
	 */
	public static String addFileProtocol(String path) throws OntoException{
		if(path==null){
			logger.error("The input path is null.");
			throw new OntoException("A null input path has been provided.");
		}
		if(!path.contains("file:/")){
			path = "file:/"+path;
		}
		return path;
	}
	
	/**
	 * Extracts the name of a mechanism from an absolute path
	 * that contains it as the last folder.
	 * 
	 * @param mechanismPath the path to the mechanism that is being processed.
	 * @return a string that is the name of the mechanism that is
	 * being processed.
	 * @throws OntoException a specialised exception designed to deal with
	 * ontology to ctml and ctml to ontology generation related errors.
	 */
	public static String mechanismName(String mechanismPath) throws OntoException {
		if(mechanismPath==null){
			logger.error("The input mechanism path is null.");
			throw new OntoException("A null input mechanism path has been provided.");
		}
		if(mechanismPath!= null && mechanismPath.contains("\\")){
			String[] tokens = mechanismPath.split("\\\\");
			if(tokens.length>1){
				return tokens[tokens.length-2];
			}
		}
		return "anonymousMechanism";
	}
	
	/**
	 * Forms a URL of a file based on the path where the file is stored plus
	 * the name of the mechanism, which is the name of folder where the 
	 * importing CTML file resides.
	 * 
	 * @param ctmlFile The path to the CTML file being processed.
	 * @param owlFilePath The path to the file being processed.
	 * @return a string representing a URL.
	 * @throws OntoException a specialised exception designed to deal with
	 * ontology to ctml and ctml to ontology generation related errors.
	 */
	public static String formOwlUrl(String ctmlFile, String mechanismABoxFilePath) throws OntoException {
		if (ctmlFile == null) {
			logger.error("Provided ctmlFile path is null.");
			throw new OntoException("Provided ctmlFile path is null.");
		}
		if (mechanismABoxFilePath == null) {
			logger.error("Provided file path is null.");
			throw new OntoException("Provided file path is null.");
		}
		mechanismABoxFilePath = ontoChemKB.getOntoKinKbURL();
		mechanismABoxFilePath = ontoChemKB.getOntoKinKbURL()
				.concat(extractMechanismName(ctmlFile)).concat(opCtrl.getOwlFileExtension());
		mechanismABoxFilePath = formatToURLSlash(mechanismABoxFilePath);
		return mechanismABoxFilePath;
	}
	
	/**
	 * Forms a URL of a file based on the path where the file is stored plus
	 * the name of the mechanism, which is the name of folder where the 
	 * importing CTML file resides.
	 * 
	 * @param ctmlFile The path to the CTML file being processed.
	 * @param owlFilePath The path to the file being processed.
	 * @return a string representing a URL.
	 * @throws OntoException a specialised exception designed to deal with
	 * ontology to ctml and ctml to ontology generation related errors.
	 */
	public static String formOwlFileSaveUrl(String ctmlFile, String owlFilePath) throws OntoException {
		if (ctmlFile == null) {
			logger.error("Provided ctmlFile path is null.");
			throw new OntoException("Provided ctmlFile path is null.");
		}
		if (owlFilePath == null) {
			logger.error("Provided file path is null.");
			throw new OntoException("Provided file path is null.");
		}
		owlFilePath = owlFilePath.concat("/").concat(ontoChemKB.getOntoKinKbRootDirectory())
				.concat(extractMechanismName(ctmlFile)).concat(opCtrl.getOwlFileExtension());
		owlFilePath = formatToURLSlash(owlFilePath);
		owlFilePath = addFileProtocol(owlFilePath);
		return owlFilePath;
	}

	
	/**
	 * Forms the base URL for an OWL ontology.
	 * 
	 * @param ctmlFile The path to the CTML file being processed.
	 * @return a string representing the base URL.
	 * @throws OntoException a specialised exception designed to deal with
	 * ontology to ctml and ctml to ontology generation related errors.
	 */
	public static String formBaseURL(String ctmlFile) throws OntoException {
		if (ctmlFile == null) {
			logger.error("Provided ctmlFile path is null.");
			throw new OntoException("Provided ctmlFile path is null.");
		}
		return ontoChemKB.getOntoKinKbURL()
				.concat(extractMechanismName(ctmlFile)).concat(opCtrl.getOwlFileExtension());
	}
	
	/**
	 * Forms an OWL formatted URL of a file based on the path where the file is stored plus
	 * the name of the file.
	 * 
	 * @param owlFilePath The path to the file being processed
	 * @return a string representing a URL
	 * @throws OntoException a specialised exception designed to deal with
	 * ontology to ctml and ctml to ontology generation related errors
	 */
	public static String formOwlUrl(String owlFilePath) throws OntoException {
		if (owlFilePath == null) {
			logger.error("Provided owlFilePath path is null.");
			throw new OntoException("Provided owlFilePath path is null.");
		}
		owlFilePath = formatToURLSlash(owlFilePath);
		owlFilePath = addFileProtocol(owlFilePath);
		return owlFilePath;
	}
	
	/**
	 * Extracts the name of the mechanism being processed from the 
	 * ctmlFile path.
	 * 
	 * @param ctmlFile The ctmlFile path.
	 * @return String returns a string that is the name of the mechanism 
	 * being processed.
	 * @throws OntoException
	 */
	public static String extractMechanismName(String ctmlFile) throws OntoException {
		if (!ctmlFile.contains(FRONTSLASH)) {
			logger.error("Unexpected ctmlFile path.");
			throw new OntoException("Unexpected ctmlFile path.");
		}
		String tokens[] = ctmlFile.split(FRONTSLASH.concat(FRONTSLASH));
		if(tokens.length<2){
			logger.error("The ctmlFile path is unexpectedly short.");
			throw new OntoException("The ctmlFile path is unexpectedly short.");
		}
		return tokens[tokens.length-2];
	}
	
	/**
	 * Extracts the material instance id from the corresponding
	 * hash map if available, it creates otherwise.
	 * 
	 * @param phaseMaterial
	 * @return
	 * @throws OntoException
	 */
	public static String extractMaterialInstanceId(String phaseMaterial) throws OntoException {
		if(phaseMaterial==null){
			logger.error("Phase material is null.");
			throw new OntoException("Phase material is null.");
		}
		if (materialVsInstanceMap.containsKey(phaseMaterial)) {
			return materialVsInstanceMap.get(phaseMaterial);
		}
		materialVsInstanceMap.put(phaseMaterial, Long.toString(++materialInstanceId));
		return Long.toString(materialInstanceId);
	}
	
	/**
	 * Creates a HashMap keeping a reaction array data source as the key and
	 * a species array data source as the value.
	 * </p>  
	 * The HashMap serves the needs of linking a species appearing in
	 * reactions to its phase. This link is important as it helps to
	 * extract the value of the HashMap that maintains the 
	 * species-name_species-data-src vs unique-id-of-species map.
	 * 
	 * 
	 * @param reactionArrayVsSpeciesArrayMap a HashMap to maintain links.
	 * between a reaction array data source and a species array data source.
	 * @see HashMap
	 */
	public static void addSpeciesArrayReactionArrayMap(HashMap<String, String> reactionArrayVsSpeciesArrayMap)
			throws OntoException {
		checkSpeciesArray(reactionArrayVsSpeciesArrayMap);
	}
	
	private static void checkSpeciesArray(HashMap<String, String> reactionArrayVsSpeciesArrayMap) throws OntoException {
		if (speciesArray.getDatasrc() != null) {
			checkReactionArray(reactionArrayVsSpeciesArrayMap);
		}
	}

	private static void checkReactionArray(HashMap<String, String> reactionArrayVsSpeciesArrayMap)
			throws OntoException {
		if (reactionArray.getDatasrc() != null) {
			addReactionSpeciesPair(reactionArrayVsSpeciesArrayMap);
		}
	}
	
	private static void addReactionSpeciesPair(HashMap<String, String> reactionArrayVsSpeciesArrayMap)
			throws OntoException {
		reactionArrayVsSpeciesArrayMap.put(extractDataSource(reactionArray.getDatasrc()),
				extractDataSource(speciesArray.getDatasrc()));
	}
	
	/**
	 * Creates a HashMap keeping a reaction array data source as the key and
	 * a material as the value.
	 * </p>  
	 * The HashMap serves the needs of linking a reaction to the material
	 * that includes the reaction. This link is important as it helps to
	 * extract the value of the HashMap that maintains the 
	 * reaction array data source name vs material map.
	 * 
	 * @param reactionArrayVsMaterialMap
	 * @throws OntoException
	 */
	public static void addReactionArrayMaterialMap(HashMap<String, String> reactionArrayVsMaterialMap)
			throws OntoException {
		checkReactionArrayForMaterial(reactionArrayVsMaterialMap);
	}

	private static void checkReactionArrayForMaterial(HashMap<String, String> reactionArrayVsMaterialMap)
			throws OntoException {
		if (reactionArray.getDatasrc() != null) {
			addReactionArrayMaterialPair(reactionArrayVsMaterialMap);
		}
	}
	
	private static void addReactionArrayMaterialPair(HashMap<String, String> reactionArrayVsMaterialMap)
			throws OntoException {
		reactionArrayVsMaterialMap.put(extractDataSource(reactionArray.getDatasrc()),
				phaseMD.getMaterial());
	}
	
	/**
	 * Creates a HashMap keeping a species array data source as the key and
	 * a phase id as the value.
	 * </p>  
	 * The HashMap serves the needs of linking a species to the phase
	 * that includes the species.
	 * 
	 * @param speciesDataSrcVsPhaseIdMap
	 * @throws OntoException
	 */
	public static void addspeciesDataSrcVsPhaseIdMap(HashMap<String, String> speciesDataSrcVsPhaseIdMap)
			throws OntoException {
		checkspeciesDataSrcForPhase(speciesDataSrcVsPhaseIdMap);
	}

	private static void checkspeciesDataSrcForPhase(HashMap<String, String> speciesDataSrcVsPhaseIdMap)
			throws OntoException {
		if (speciesArray.getDatasrc() != null) {
			addSpeciesDataSrcVsPhaseIdPair(speciesDataSrcVsPhaseIdMap);
		}
	}
	
	private static void addSpeciesDataSrcVsPhaseIdPair(HashMap<String, String> speciesDataSrcVsPhaseIdMap)
			throws OntoException {
		speciesDataSrcVsPhaseIdMap.put(extractDataSource(speciesArray.getDatasrc()),
				phaseMD.getId());
	}
	
	/**
	 * Creates a HashMap keeping a reaction array data source as the key and
	 * a material as the value.
	 * </p>  
	 * The HashMap serves the needs of linking a reaction to the material
	 * that includes the reaction. This link is important as it helps to
	 * extract the value of the HashMap that maintains the 
	 * reaction array data source name vs material map.
	 * 
	 * @param reactionArrayVsMaterialMap
	 * @throws OntoException
	 */
	/**
	 * Creates a HashMap keeping a reaction/species array data source as the
	 * key and the corresponding phase instance id as the value.
	 * </p>
	 * The HashMap serves the needs of linking a gas phase species or reaction
	 * to its phase.
	 * 
	 * @param gasPhaseDataSrcVsInstanceMap
	 * @throws OntoException
	 */
	public static void addGasPhaseDataSrcVsInstanceMap(HashMap<String, String> gasPhaseDataSrcVsInstanceMap)
			throws OntoException {
		checkGasPhaseDataSrc(gasPhaseDataSrcVsInstanceMap);
	}

	private static void checkGasPhaseDataSrc(HashMap<String, String> gasPhaseDataSrcVsInstanceMap)
			throws OntoException {
		if (reactionArray.getDatasrc() != null) {
			addGasPhaseDataSrcPhasePair(gasPhaseDataSrcVsInstanceMap, reactionArray.getDatasrc());
		}
		if (speciesArray.getDatasrc() != null) {
			addGasPhaseDataSrcPhasePair(gasPhaseDataSrcVsInstanceMap, speciesArray.getDatasrc());
		}
	}
	
	private static void addGasPhaseDataSrcPhasePair(HashMap<String, String> gasPhaseDataSrcVsInstanceMap,
			String dataSrc) throws OntoException {
		gasPhaseDataSrcVsInstanceMap.put(extractDataSource(dataSrc),
				appConfigOntokin.getOntokinPhase().concat(UNDERSCORE).concat(Long.toString(phaseInstanceId)));
	}
	
	/**
	 * Removes the beginning hash (#) symbol from a data source name. 
	 * 
	 * @param dataSource either species array data source (e.g. #GAS_species_data) 
	 * or reaction array data source (e.g. #GAS_reaction_data).
	 * @return String the data source following the removal of hash 
	 * (e.g. GAS_species_data and GAS_reaction_data)
	 * @throws OntoException
	 * @see String
	 */
	private static String extractDataSource(String dataSource) throws OntoException {
		if (dataSource.startsWith(HASH)) {
			return dataSource.replaceFirst(HASH, EMPTY);
		}
		return dataSource;
	}
	
	/**
	 * Splits the space separated species and put them in two hash maps.</br>
	 * - one keeps species vs phase map and.
	 * - another keeps species vs phase class map.
	 * </br>
	 * Also creates a species-unique id map.  
	 * 
	 * @param speciesPhaseMap species vs phase map
	 * @param speciesVsPhaseClassMap species vs phase class map
	 * @param keys space separated species
	 * @param value the type of the phase
	 * @param appendToKey the part to append to the keys (e.g. _MATERIAL1_species_data)
	 * @throws OntoException
	 */
	public static void createKeyValuePairs(HashMap<String, String> speciesPhaseMap,HashMap<String, String> speciesVsPhaseClassMap, String keys, String value, String appendToKey)
			throws OntoException {
		// Calls the method that checks if speciesPhaseMap is null
		checkHashMap(speciesPhaseMap);
		// Calls the method that checks if speciesVsPhaseClassMap is null
		checkHashMap(speciesVsPhaseClassMap);
		// Calls the method that checks if keys are null or empty
		checkKeys(keys);		
		// Calls the method that checks if a value is null
		checkValue(value);
		String[] tokens = keys.split(SPACE);
		createKeyValuePairs(speciesPhaseMap, speciesVsPhaseClassMap, tokens, value, appendToKey);
	}

	/**
	 * Splits the space separated species and put them in a hash map. Also
	 * creates a species-unique id map.
	 * 
	 * @param hashMap
	 * @param tokens
	 * @param value
	 * @param appendToKey
	 * @throws OntoException
	 */
	private static void createKeyValuePairs(HashMap<String, String> speciesPhaseMap, HashMap<String, String> speciesVsPhaseClassMap, String[] tokens, String value,
			String appendToKey) throws OntoException {
		for (String token : tokens) {
			// Maintains species-uniqueId map to distinguish
			// between species. For example, species RB01 will
			// be represented as RB01_BULK1_MATERIAL1.
			String speciesId = Long.toString(++speciesInstanceId).concat(UNDERSCORE).concat(Long.toString(++speciesSerialNo));
			if (phaseMD.getMaterial() == null) {
				speciesUniqueIDMap.put(token.concat(appendToKey), appConfigOntokin.getClassSpecies().concat(UNDERSCORE).concat(speciesId));
			} else {
				speciesUniqueIDMap.put(token.concat(appendToKey),
						appConfigOntokin.getClassSpecies().concat(UNDERSCORE).concat(speciesId));
			}
			speciesPhaseMap.put(token.concat(appendToKey), value);
			speciesVsPhaseClassMap.put(token.concat(appendToKey), phaseType);
		}
	}
	
	/**
	 * The utility method that checks if a hashmap is null.
	 * 
	 * @param hashMap
	 * @throws OntoException
	 */
	private static void checkHashMap(HashMap<String, String> hashMap) throws OntoException{
		if (hashMap == null) {
			logger.error("The instance of HashMap is null within a phase.");
			throw new OntoException("HashMap is null within a phase.");
		}
	}
	
	/**
	 * The utility method that checks if keys are null.
	 * 
	 * @param keys
	 * @throws OntoException
	 */
	private static void checkKeys(String keys) throws OntoException{
		if (keys == null) {
			logger.error("The list of keys is null.");
			throw new OntoException("The list of keys is null.");
		}
		if (keys.isEmpty()) {
			logger.error("The list of keys is empty.");
			throw new OntoException("The list of keys is empty.");
		}		
	}
	
	/**
	 * The utility method that checks if a value is null.
	 * 
	 * @param value
	 * @throws OntoException
	 */
	private static void checkValue(String value) throws OntoException{
		if (value == null) {
			logger.error("The value is null.");
			throw new OntoException("The value is null.");
		}
		if (value.isEmpty()) {
			logger.error("The value is null.");
			throw new OntoException("The value is null.");
		}
	}
	
	/**
	 * Splits a space separated string into tokens.</br>
	 * Splits each token into two parts using colon(:) to 
	 * extract key value pairs.   
	 * 
	 * @param string
	 * @return
	 * @throws OntoException
	 */
	public static LinkedHashMap<String, String> createKeyValuePair(String string) throws OntoException{
		LinkedHashMap<String, String> hashMap = new LinkedHashMap<String, String>();
		checkValue(string);
		String[] tokens = string.split(SPACE);
		createKeyValuePairs(tokens, hashMap);
		return hashMap;
	}
	
	private static void createKeyValuePairs(String[] tokens, LinkedHashMap<String, String> hashMap) throws OntoException{
		for(String token:tokens){
			createKeyValuePairs(token, hashMap);
		}
	}
	
	private static void createKeyValuePairs(String token, LinkedHashMap<String, String> hashMap) throws OntoException {
		if (token.contains(":")) {
			String[] tokens = token.split(":");
			hashMap.put(tokens[0], tokens[1]);
		}
	}
	
	/**
	 * Upon receiving a string of space separated tokens it splits the string
	 * to extract each token, puts the tokens in an Array List and returns.  
	 * 
	 * @param parameters
	 * @return ArrayList
	 * @throws OntoException
	 */
	public static ArrayList<String> separateParameters(String parameters) throws OntoException{
		ArrayList<String> list = new ArrayList<String>();
		if(parameters == null){
			logger.error("Parameters sent to split using a space is null.");
			throw new OntoException("Space separated parameters sent to split is null.");
		}
		if(!parameters.contains(SPACE)){
			logger.error("Parameters sent to split using space does not "
					+ "contain a space. Therefore, it might lead to "
					+ "unexpected result.");
			throw new OntoException("Space separated parameters sent to "
					+ "split does not contain a space.");
		}
		for(String token:parameters.split(SPACE)){
			list.add(token);
		}
		return list;
	}
	
	/**
	 * Checks the presence of carriage return (\r) and newline (\n) 
	 * characters and forwards the call to the methods that
	 * remove them.
	 * 
	 * @param data
	 * @return String
	 */
	public static String normaiseMultiLineData(String data){
		if(data!=null){
			if(data.contains("\r\n")){
				return removeNewLine(data, "\r\n");
			}
			if(data.contains("\n")){
				return removeNewLine(data, "\n");
			}
		}
		return data;
	}
	
	/**
	 * Removes carriage return (\r) and newline (\n) characters from a string.
	 * 
	 * @param data
	 * @param splittingText
	 * @return
	 */
	private static String removeNewLine(String data, String splittingText){
		StringBuffer sb = new StringBuffer();
		String[] tokens = data.split(splittingText);
		int size = tokens.length;
		int count = 0;
		for(String token:tokens){
			if(++count<size){
				sb.append(token.trim()).append(SPACE);
			}else{
				sb.append(token.trim());
			}
		}
		return sb.toString();
	}
	
	/**
	 * Converts a phase dimension and the presence of the phase dimension
	 * into an OWL compatible class name.
	 * 
	 * @return String the OWL compatible class of a CTML phase   
	 * @throws OntoException
	 */
	public static String getPhase() throws OntoException{
		if(phaseMD==null && phaseMD.getDimension()==null){
			logger.error("The dimension of a phase is null.");
			throw new OntoException("The dimension of a phase is null.");
		}
		if(phaseMD.getDimension().equalsIgnoreCase("2")){
			reactionDataIdVsPhaseMap.put(getReactionDataId(reactionArray.getDatasrc()), appConfigOntokin.getClassSitePhase());
			return appConfigOntokin.getClassSitePhase();
		} else if(phaseMD.getDimension().equalsIgnoreCase("3") && phaseMD.getPhaseArray()!=null){
			reactionDataIdVsPhaseMap.put(getReactionDataId(reactionArray.getDatasrc()), appConfigOntokin.getClassBulkPhase());
			return appConfigOntokin.getClassBulkPhase();
		} else if(phaseMD.getDimension().equalsIgnoreCase("3") && phaseMD.getPhaseArray()==null){
			reactionDataIdVsPhaseMap.put(getReactionDataId(reactionArray.getDatasrc()), appConfigOntokin.getClassGasPhase());
			return appConfigOntokin.getClassGasPhase();
		}
		//If none of the above phases match, the parser reports it as an error.
		logger.error("For the following phase, no OWL phase class matched.");
		throw new OntoException("For the following phase, no OWL phase class matched.");
	}
	
	/**
	 * Removes the starting has symbol (if present) from the reactionArray 
	 * data source. 
	 * 
	 * @param reactionDataId
	 * @return
	 * @throws OntoException
	 */
	private static String getReactionDataId(String reactionDataId) throws OntoException{
		if(reactionDataId.startsWith(HASH)){
			return reactionDataId = reactionDataId.substring(1, reactionDataId.length());
		}
		//If none of the above phases match, the parser reports it as an error.
		logger.error("For the following phase, no OWL phase class matched.");
		throw new OntoException("For the following phase, no OWL phase class matched.");		
	}
	
	/**
	 * Replaces a specific substring (replacee) from a string with another
	 * specific substring (replacer).
	 * 
	 * @param string
	 * @param replacee
	 * @param replacer
	 * @return
	 */
	public static String removeSpecificString(String string, String replacee, String replacer){
		if(string.contains(replacee)){
			string = string.replace(replacee, replacer);
		}
		return string;
	}
	
	/**
	 * Converts a CTML class name into an OWL compatible class name.
	 * 
	 * @param classCtmlName the name of the reaction class found in CTML. 
	 * @return String OWL compatible class name of the CTML class. 
	 * @throws OntoException
	 */
	public static String getReactionClass(String classCtmlName) throws OntoException{
		if(classCtmlName==null){
			logger.error("CTML class name requested to be converted to an OWL class name is null.");
			throw new OntoException("CTML class name requested to be converted to an OWL class name is null.");
		}
		if(classCtmlName.equalsIgnoreCase(appConfigCtml.getReactionTypeFallOffCHEBValue())){
			return appConfigOntokin.getClassCHEBReaction();
		}
		if(classCtmlName.equalsIgnoreCase(appConfigCtml.getReactionTypeFallOffLindemannValue())){
			return appConfigOntokin.getClassLindemannReaction();
		}
		if(classCtmlName.equalsIgnoreCase(appConfigCtml.getReactionTypeFallOffPLOGValue())){
			return appConfigOntokin.getClassPLOGReaction();
		}
		if(classCtmlName.equalsIgnoreCase(appConfigCtml.getReactionTypeFallOffSRIValue())){
			return appConfigOntokin.getClassSRIReaction();
		}
		if(classCtmlName.equalsIgnoreCase(appConfigCtml.getReactionTypeFallOffTroeValue())){
			return appConfigOntokin.getClassTroeReaction();
		}
		if(classCtmlName.equalsIgnoreCase(appConfigCtml.getReactionTypeFallOffValue())){
			return appConfigOntokin.getClassFallOffReaction();
		}
		if(classCtmlName.equalsIgnoreCase(appConfigCtml.getReactionTypeSurfaceValue())){
			return appConfigOntokin.getClassSurfaceReaction();
		}
		if(classCtmlName.equalsIgnoreCase(appConfigCtml.getReactionTypeThreeBodyValue())){
			return appConfigOntokin.getClassThreeBodyReaction();
		}
		return appConfigOntokin.getClassReaction();
	}
	
	/**
	 * Splits an input string containing a list of chemical elements 
	 * using a single space.
	 * 
	 * @param elementArray a string containing space separated chemical elements
	 * @return the array of chemical elements
	 * @throws OntoException
	 */
	public static String[] getElements(String elementArray) throws OntoException{
		if(elementArray==null){
			logger.error("The elementArray requested to be split into elements is null.");
			throw new OntoException("The elementArray requested to be split into elements is null.");
		}
		return elementArray.split(SPACE);
	}
	
	/**
	 * Splits an input string containing a list of atom:quantity pairs 
	 * using a single space.
	 * 
	 * @param atomArray a string containing space separated atom:quantity pairs
	 * @return an array of atom:quantity pairs
	 * @throws OntoException
	 */
	public static String[] getAtomSpecifications(String atomArray) throws OntoException{
		if(atomArray==null){
			logger.error("The atomArray requested to be split into atom:quanity is null.");
			throw new OntoException("The atomArray requested to be split into atom:quantity is null.");
		}
		atomArray = getSingleLineFromMultilineString(atomArray);
		return atomArray.split(SPACE);
	}
	
	/**
	 * Splits an input string containing a list of species:stoichiometric 
	 * coefficient pairs using a single space.
	 * 
	 * @param products a string containing space separated 
	 * species:stoichiometric coefficient pairs
	 * @return an array of species:stoichiometric coefficient pairs
	 * @throws OntoException
	 */
	public static String[] getProductSpecifications(String products) throws OntoException{
		if(products==null){
			logger.error("The products requested to be split into species:quantity is null.");
			throw new OntoException("The products requested to be split into species:quantity is null.");
		}
		products = getSingleLineFromMultilineString(products);
		return products.split(SPACE);
	}
	
	/**
	 * Converts a space separated multiline string into a single line string.
	 * 
	 * @return
	 */
	private static String getSingleLineFromMultilineString(String string){
		if(string.contains("\n")){
			String tokenList = "";
			String[] tokens = string.split("\n");
			for(String token:tokens){
				token = token.trim();
				tokenList = tokenList.concat(token).concat(SPACE);
			}
			string = tokenList.trim();
		}
		return string;
	}
	
	/**
	 * Splits an input string containing a list of species:stoichiometric 
	 * coefficient pairs using a single space.
	 * 
	 * @param reactants a string containing space separated 
	 * species:stoichiometric coefficient pairs
	 * @return an array of species:stoichiometric coefficient pairs
	 * @throws OntoException
	 */
	public static String[] getReactantSpecifications(String reactants) throws OntoException{
		if(reactants==null){
			logger.error("The reactants requested to be split into species:quantity is null.");
			throw new OntoException("The reactants requested to be split into species:quantity is null.");
		}
		reactants = getSingleLineFromMultilineString(reactants);
		return reactants.split(SPACE);
	}
	
	public static String getElement(String atomVsQuantity) throws OntoException{
		if(atomVsQuantity==null){
			logger.error("The atomVsQuantity requested to be split is null.");
			throw new OntoException("The atomVsQuantity requested to be split is null.");
		}
		if(!atomVsQuantity.contains(COLON)){
			logger.error("The atomVsQuantity does not contain a colon.");
			throw new OntoException("The atomVsQuantity does not contain a colon.");
		}
		return atomVsQuantity.split(COLON)[0];
	}
	
	public static String getElementQuantity(String atomVsQuantity) throws OntoException{
		return atomVsQuantity.split(COLON)[1];
	}
	
	public static String getSpecies(String speciesVsQuantity) throws OntoException{
		if(speciesVsQuantity==null){
			logger.error(speciesVsQuantity+" requested to be split is null.");
			throw new OntoException(speciesVsQuantity+" requested to be split is null.");
		}
		if(!speciesVsQuantity.contains(COLON)){
			logger.error(speciesVsQuantity+" does not contain a colon in the reaction :"+reaction.getEquation());
			throw new OntoException(speciesVsQuantity+" does not contain a colon in the reaction :"+reaction.getEquation());
		}
		return speciesVsQuantity.split(COLON)[0];
	}
	
	public static String getStoichioMetricCoefficient(String speciesVsQuantity) throws OntoException{
		if(speciesVsQuantity==null){
			logger.error(speciesVsQuantity+" requested to be split is null.");
			throw new OntoException(speciesVsQuantity+" requested to be split is null.");
		}
		if(!speciesVsQuantity.contains(COLON)){
			logger.error(speciesVsQuantity+" does not contain a colon in the prodcuts and reactancts:"+reaction.getProducts() +" and "+reaction.getReactants());
			throw new OntoException(speciesVsQuantity+" does not contain a colon in the prodcuts and reactancts:"+reaction.getProducts() +" and "+reaction.getReactants());
		}
		if(speciesVsQuantity.split(COLON).length!=2){
			logger.error("The length of "+speciesVsQuantity+" is not 2, therefore, it should be fixed in the prodcuts and reactancts:"+reaction.getProducts() +" and "+reaction.getReactants());
			throw new OntoException("The length of "+speciesVsQuantity+" is not 2, therefore, it should be fixed in the prodcuts and reactancts:"+reaction.getProducts() +" and "+reaction.getReactants());
		}
		return speciesVsQuantity.split(COLON)[1];
	}
	
	/**
	 * Checks if the current ontology contains an IRI. If an IRI is available
	 * it is returned, otherwise the OntoException exception is thrown.
	 * 
	 * @param ontology
	 * @return IRI the IRI of the input ontology 
	 * @throws OntoException
	 */
	public static IRI readOntologyIRI(OWLOntology ontology) throws OntoException{
		if(ontology.getOntologyID().getOntologyIRI().isPresent()){
			return ontology.getOntologyID().getOntologyIRI().get();
		} else{
			logger.error("The OWL file does not contain an IRI.");
			throw new OntoException("The OWL file does not contain an IRI.");
		}
	}
	
	/**
	 * Creates and returns an instance of the BufferedReader class.
	 * It takes 
	 * 
	 * @param filePathPlusName
	 *            the path plus name of the file being read
	 * @return
	 * @throws IOException
	 */
	public static BufferedReader openSourceFile(String filePathPlusName)
			throws IOException {
		return new BufferedReader(new InputStreamReader(new FileInputStream(
				filePathPlusName), "UTF-8"));
	}

}
