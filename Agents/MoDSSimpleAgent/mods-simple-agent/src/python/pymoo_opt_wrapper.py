"""
   Wrapper to allow MoDS to construct and run MOO algorithms from the pymoo library.
"""

# Core modules
import datetime
import logging
import numpy as np
import os.path
import sys
import tempfile
import traceback
import types

# pymoo modules and functions
from pymoo.factory import get_algorithm, get_reference_directions, get_termination
from pymoo.model.problem import Problem
from pymoo.optimize import minimize

# Module generated by MoDS at runtime; provides access to objective function evaluator
import modsOF

# Constants used in multiple functions
ref_dirs_prefix="ref_dirs:"

#--------------------------------------------------------------------------------------------------
class MoDSProblem(Problem):
    """Define a pymoo Problem that retrieves the OF vector via the modsOF module."""
    def __init__(self):
        nTheta  = modsOF.Get_nTheta()
        nObj    = modsOF.Get_nOFs()
        # No constraints for now
        nConstr = 0
        #nConstr = modsOF.Get_nConstraints()
        super().__init__(n_var=nTheta,n_obj=nObj, n_constr=nConstr, xl=nTheta*[-1], xu=nTheta*[1], elementwise_evaluation=True)
    def _evaluate(self, x, out, *args, **kwargs):
        out["F"] = modsOF.EvaluateOFs(list(x))
        # No constraints for now
        #out["G"] = modsOF.EvaluateConstraints(x)
#--------------------------------------------------------------------------------------------------

#--------------------------------------------------------------------------------------------------
def generate_termination_obj(kwargs):
    """
    Extract keywords prefixed with <term_prefix> from <kwargs>, pass them to get_termination(), then return the result.
    Other than checking that the user supplied a termination type, there's no validation of the keyword args
    """
    term_prefix = "term:"

    term_keys = [k[len(term_prefix):] for k in kwargs.keys() if k.startswith(term_prefix)]
    if term_keys:
        term_kwargs = {}
        for k in term_keys:
                term_kwargs[k] = kwargs.pop(term_prefix+k)
        term_type = term_kwargs.pop("type",None)
        if term_type is None:
            raise TypeError("Termination keywords were supplied, but termination type (%stype) is missing" % term_prefix)
        term =  get_termination(term_type,**term_kwargs)
    else:
        # Default to limit of 100 generations
        term =  get_termination("n_gen", 100)

    return term
#--------------------------------------------------------------------------------------------------

#--------------------------------------------------------------------------------------------------
def init_logging(log_dir,log_fname,log_level_str):
    """Initialise the log file"""
    log_fpath = os.path.join(log_dir,log_fname)
    log_level = logging._nameToLevel[log_level_str] if log_level_str in logging._nameToLevel else logging.INFO
    logging.basicConfig(filename=log_fpath, filemode='w', level=log_level)
#--------------------------------------------------------------------------------------------------

#--------------------------------------------------------------------------------------------------
def process_ref_dirs_kwargs(kwargs):
    """
       Extract keywords relating to reference directions (if any exist), build the reference
       directions object, and put it back into the keyword dict to be passed on to the algorithm
    """

    ref_dirs_kwarg_names = [ k[len(ref_dirs_prefix):] for k in kwargs.keys() if k.startswith(ref_dirs_prefix) ]
    if ref_dirs_kwarg_names:
        ref_dirs_kwargs=dict(n_dim=modsOF.Get_nOFs())
        for kwarg_name in ref_dirs_kwarg_names:
            ref_dirs_kwargs[kwarg_name] = kwargs.pop(ref_dirs_prefix+kwarg_name)
        logging.info("Constructing ref_dirs with arguments:"+str(ref_dirs_kwargs))
        ref_dirs = get_reference_directions(**ref_dirs_kwargs)
        kwargs["ref_dirs"] = ref_dirs
#--------------------------------------------------------------------------------------------------

#--------------------------------------------------------------------------------------------------
def resolve_kw_conflicts(kwargs):
    """
    Adjust keyword values if any of them are inconsistent with one another
    """
    # Ensure the number of reference directions doesn't exceed the population size
    nref_dirs_key = ref_dirs_prefix+"n_points"
    pop_size_key = "pop_size"
    if nref_dirs_key in kwargs and pop_size_key in kwargs:
        if kwargs[nref_dirs_key] > kwargs[pop_size_key]:
            logging.warn("Number of reference directions cannot be greater than the population size; setting it to %d." % kwargs[pop_size_key])
            kwargs[nref_dirs_key] = min(kwargs[nref_dirs_key],kwargs[pop_size_key])
#--------------------------------------------------------------------------------------------------

#--------------------------------------------------------------------------------------------------
def run(args, **kwargs):
    """Wrapper entrypoint"""

    # Process keywords and set defaults
    algorithm_type = kwargs.pop('algorithm_type','nsga3')
    log_dir        = kwargs.pop('log_dir',tempfile.gettempdir())
    log_fname      = kwargs.pop('log_fname','pymoo_log.txt')
    log_level_str  = str.upper(kwargs.pop('log_level','INFO'))
    kwargs["seed"] = kwargs.pop("seed", 1)

    # Initialise logging
    init_logging(log_dir,log_fname,log_level_str)
    logging.info("Running pymoo at "+datetime.datetime.now().strftime("%H:%M:%S on %d/%m/%Y\n"))

    # Initialise numpy with the same random seed passed to pymoo
    np.random.seed(kwargs["seed"])

    # Adjust keywords object if any of the values conflict with one another
    resolve_kw_conflicts(kwargs)

    # Extract termination conditions and generate the Termination object 
    try:
        termination = generate_termination_obj(kwargs)
    except Exception as ex:
        logging.error("Termination condition set up failed with " +str(ex))
        return False

    # Generate the ref_dirs object, if one has been requested
    process_ref_dirs_kwargs(kwargs)

    # Remaining kwargs passed to algorithm
    algorithm_settings = kwargs

    # Problem set up
    try:
        logging.info("Setting up problem with %d optimisables, %d objectives" % (modsOF.Get_nTheta(),modsOF.Get_nOFs()))
        problem = MoDSProblem()
        logging.info("Problem set up complete.\n")
    except:
        logging.error("Failed to setup pymoo problem.")
        logging.error("Error was: "+str(ex))
        return False

    # Algorithm set up
    # Note that, to simplify things, we don't pass separate *args and **kwargs to get_algorithm()
    # Instead standard args (e.g. ref_dirs for nsga3) are passed on to the algorithm constructors
    # in kwarg format, i.e. get_algorithm(algorithm_type, arg1=1, arg2=false, kwarg1=2, kwarg2=1.0)
    try:
        logging.info("Setting up algorithm [%s]%s" % (algorithm_type,str(algorithm_settings)))
        algorithm = get_algorithm(algorithm_type, **algorithm_settings)
        logging.info("Algorithm set up complete.\n")
    except Exception as ex:
        logging.error("Error setting up pymoo algorithm: "+str(ex))
        return False

    # Run MOO
    logging.info("Running optimisation...")
    err_msg = ""
    try:
        result = minimize(problem, algorithm, termination=termination, verbose=True, seed=1)
        # N.B. result.success doesn't always seem to be set - check for None here
        success = True if result.success is None else result.success
        err_msg = result.message
    except Exception as ex:
        logging.error("Error running optimisation: "+str(ex))
        stack_trace = traceback.format_exc()
        logging.error("Full stacktrace: "+stack_trace)
        success = False

    if success:
        logging.info("Optimisation finished in %f s" % result.exec_time)
    else:
        if err_message:
            logging.error("Optimisation failed; error message was")
            logging.error(err_message)
    return success
#--------------------------------------------------------------------------------------------------

# Do nothing if run directly
if __name__ == "__main__":
    pass