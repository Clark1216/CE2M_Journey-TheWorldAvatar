class DataGroup {
    constructor() {
        this.dataSources = [], this.dataLayers = [], this.subGroups = [], this.defaultExpanded = !0
    }
    parseDataSources(e) {
        for (var t = 0; t < e.length; t++) {
            var a = e[t],
                n = new DataSource(a),
                a = this.id + "." + a.id;
            n.id = a, this.dataSources.push(n)
        }
    }
    parseDataLayers(t, e) {
        for (var a = 0; a < e.length; a++) {
            var n = e[a],
                i = this.findSource(n.source);
            if (null == i) console.error("Layer with id '" + n.id + "' references a source that is not defined, will skip it!");
            else {
                n.source = i.id;
                let e = null;
                var r = this.id + "." + n.id;
                switch (Manager.PROVIDER) {
                    case MapProvider.MAPBOX:
                        e = new MapboxLayer(r, n.name, i), n.hasOwnProperty("order") && (e.order = n.order), Manager.STACK_LAYERS.hasOwnProperty(t) || (Manager.STACK_LAYERS[t] = []), Manager.STACK_LAYERS[t].push(r);
                        break;
                    case MapProvider.CESIUM:
                        e = new CesiumLayer(r, n.name, i), n.hasOwnProperty("order") && (e.order = n.order), Manager.STACK_LAYERS.hasOwnProperty(t) || (Manager.STACK_LAYERS[t] = []), Manager.STACK_LAYERS[t].push(r);
                        break;
                    default:
                        throw new Error("Unknown map provider specified!")
                }
                e.definition = n, this.dataLayers.push(e)
            }
        }
    }
    findSource(e) {
        var t = [];
        return this.recurseFindSource(t, this, e), 1 === t.length ? t[0] : null
    }
    recurseFindSource(e, t, a) {
        var n = t.dataSources.find(e => {
            e = e.id.split(".");
            return e[e.length - 1] === a
        });
        null == n ? null !== t.parentGroup && void 0 !== t.parentGroup && this.recurseFindSource(e, t.parentGroup, a) : e.push(n)
    }
    getLayerWithID(e) {
        var t = [];
        return this.recurseFindLayer(t, this, e), 1 === t.length ? t[0] : null
    }
    recurseFindLayer(t, e, a) {
        var n = e.dataLayers.find(e => e.id === a);
        null == n ? e.subGroups.forEach(e => {
            this.recurseFindLayer(t, e, a)
        }) : t.push(n)
    }
    flattenDown() {
        var e = [];
        return this.recurseFlattenDownLayers(e, this), e
    }
    recurseFlattenDownLayers(t, e) {
        null != e && (e.dataLayers.forEach(e => {
            t.push(e)
        }), e.subGroups.forEach(e => {
            this.recurseFlattenDownLayers(t, e)
        }))
    }
}
class DataLayer {
    constructor(e, t, a) {
        this.order = 0, this.id = e, this.name = t, this.source = a, console.info("Created DataLayer instance '" + this.name + "' with id '" + this.id + "'.")
    }
    isClickable() {
        return null != this.definition && "clickable" in Object.keys(this.definition) && this.definition.clickable
    }
}
class DataSource {
    constructor(e) {
        this.validateJSON(e), this.definition = e, this.id = e.id, this.type = e.type, console.info("Created DataSource instance '" + this.id + "'.")
    }
    validateJSON(e) {
        if (null == e) throw new ReferenceError("'json' is not a non-null object.");
        if (!("id" in e)) throw new ReferenceError("Must contain a 'id' property.");
        if (!("type" in e)) throw new ReferenceError("Must contain a 'type' property.")
    }
}
class DataStore {
    constructor() {
        this.dataGroups = []
    }
    getGroup(t) {
        let a = [];
        return this.dataGroups.every(e => {
            0 === a.length && this.recurseFindGroup(e, t, 0, a)
        }), 0 !== a.length ? a[0] : null
    }
    recurseFindGroup(e, t, a, n) {
        a < 0 || null === e || t[a] === e.name && (a === t.length - 1 ? n[0] = e : e.subGroups.forEach(e => {
            this.recurseFindGroup(e, t, a + 1, n)
        }))
    }
    loadDataGroups(e) {
        console.log("Reading definition file at: " + e);
        let t = this;
        return $.getJSON(e, function(e) {
            t.recurseLoadDataGroups(e, null, null, t.dataGroups.length)
        }).fail(e => {
            throw e
        })
    }
    recurseLoadDataGroups(e, t, a, n) {
        if (!e.name) throw new Error("Cannot parse a DataGroup that has no name!");
        e.stack && (a = updateURL(e.stack));
        var i = new DataGroup;
        if (i.name = e.name, i.id = n.toString(), null !== t && (i.id = t.id + "." + n), (null == t ? this.dataGroups : (i.parentGroup = t).subGroups).push(i), e.hasOwnProperty("expanded") && (i.defaultExpanded = e.expanded), e.sources && i.parseDataSources(e.sources), e.layers && i.parseDataLayers(a, e.layers), e.groups)
            for (var r = 0; r < e.groups.length; r++) {
                var l = e.groups[r];
                this.recurseLoadDataGroups(l, i, a, r)
            }
    }
    getLayerWithID(e) {
        for (var t = 0; t < this.dataGroups.length; t++) {
            var a = this.dataGroups[t].getLayerWithID(e);
            if (null !== a) return a
        }
        return null
    }
}
class DataUtils {
    static updateTypes(e) {
        var t = e.locationType;
        if (null != t) {
            switch (t) {
                case "circle":
                case "point":
                case "symbol":
                    e.dataType = "point";
                    break;
                case "line":
                case "connection":
                    e.dataType = "line";
                    break;
                case "fill":
                case "polygon":
                case "building":
                case "extrusion":
                    e.dataType = "polygon"
            }
            delete e.locationType
        }
    }
    static getDefaultGroup(e) {
        return 0 < e.subGroups.length ? DataUtils.getDefaultGroup(e.subGroups[0]) : e
    }
    static getRootGroup(e) {
        return null === e.parentGroup || void 0 === e.parentGroup ? e : DataUtils.getRootGroup(e.parentGroup)
    }
    static getLayer(e, t) {
        let a = [];
        t.includes(".") ? a = t.split(".") : a.push(t);
        e = DataUtils.findGroup(e.dataGroups[t[0]], a.slice(1, -1), 0), t = a[-1];
        return e.getLayerWithID[t]
    }
    static findGroup(e, t, a) {
        var n;
        return 0 < e.subGroups.length && a < t.length ? (n = t[a], DataUtils.findGroup(e.subGroups[n], t, a + 1)) : e
    }
    static getAllLayerIDs(e) {
        let t = [];
        return e.dataGroups.forEach(e => {
            DataUtils.getLayerIDs(t, e)
        }), t
    }
    static getLayerIDs(t, e) {
        e.dataLayers.forEach(e => {
            t.push(e.id)
        }), e.subGroups.forEach(e => {
            DataUtils.getLayerIDs(t, e)
        })
    }
}
class Settings {
    loadSettings(e) {
        console.log("Reading settings file at: " + e);
        let t = this;
        return $.getJSON(e, function(e) {
            if (t.settings = e, null == t.settings.imagery) switch (Manager.PROVIDER) {
                case MapProvider.MAPBOX:
                    MapboxUtils.generateDefaultImagery();
                    break;
                case MapProvider.CESIUM:
                    CesiumUtils.generateDefaultImagery()
            }
        }).fail(e => {
            throw e
        })
    }
    getSetting(e) {
        return null != this.settings ? this.settings[e] : null
    }
    putSetting(e, t) {
        this.settings[e] = t
    }
}
class Manager {
    constructor(e) {
        switch (this.inFullscreen = !1, Manager.PROVIDER = e, this.controlHandler = new ControlHandler, this.panelHandler = new PanelHandler(this), e) {
            case MapProvider.MAPBOX:
                this.mapHandler = new MapHandler_Mapbox(this);
                break;
            case MapProvider.CESIUM:
                this.mapHandler = new MapHandler_Cesium(this);
                break;
            default:
                throw new Error("Unknown map provider specified!")
        }
    }
    initialiseMap() {
        var e = Manager.SETTINGS.getSetting("start");
        this.mapHandler.initialiseMap(e), this.controlHandler.showControls(), this.controlHandler.rebuildTree(Manager.DATA_STORE), this.panelHandler.toggleMode(), showAttributions();
        let t = this;
        document.addEventListener("keydown", function(e) {
            if ((e.ctrlKey || e.metaKey) && "f" === e.key) {
                if (null === t.searchHandler || void 0 === t.searchHandler) switch (Manager.PROVIDER) {
                    case MapProvider.MAPBOX:
                        t.searchHandler = new SearchHandler_Mapbox;
                        break;
                    case MapProvider.CESIUM:
                }
                null != t.searchHandler && t.searchHandler.toggle(), e.preventDefault()
            }
        })
    }
    toggleFullscreen() {
        var e;
        this.inFullscreen ? (document.getElementById("controlsContainer").style.display = "block", document.getElementById("sidePanel").style.display = "block", (e = document.getElementById("sidePanel")).classList.contains("large") ? document.getElementById("map").style.width = "100%" : e.classList.contains("collapsed") ? document.getElementById("map").style.width = "calc(100% - 28px)" : document.getElementById("map").style.width = "calc(100% - 500px)", this.inFullscreen = !1) : (document.getElementById("controlsContainer").style.display = "none", document.getElementById("sidePanel").style.display = "none", document.getElementById("map").style.width = "100%", this.inFullscreen = !0), Manager.PROVIDER === MapProvider.MAPBOX ? MapHandler.MAP.resize() : MapHandler.MAP.scene.requestRender()
    }
    loadDefinitions() {
        Manager.STACK_LAYERS = {};
        var e = [];
        return Manager.SETTINGS = new Settings, e.push(Manager.SETTINGS.loadSettings("./settings.json")), e.push(Manager.DATA_STORE.loadDataGroups("./data.json")), Promise.all(e)
    }
    loadImagesAndLinks() {
        var e = [],
            t = (Manager.PROVIDER === MapProvider.MAPBOX && (t = this.mapHandler.addIcons("./icons.json"), e.push(t)), e.push(this.panelHandler.addLinks("./links.json")), Promise.all(e).catch(function(e) {
                console.warn("Loading icons and/or links has failed, these will be skipped.")
            }));
        return t
    }
    getMapHandler() {
        return this.mapHandler
    }
    getPanelHandler() {
        return this.panelHandler
    }
    getControlHandler() {
        return this.controlHandler
    }
    plotData() {
        this.mapHandler.plotData(Manager.DATA_STORE)
    }
    async featureSelectChange(e) {
        var t;
        null !== window.selectFeatures && void 0 !== window.selectFeatures ? (t = window.selectFeatures[e.value], this.showFeature(t, t.properties)) : console.error("Could not find feature cached with key: " + e.value), window.selectFeatures = {}
    }

    showFeature(e, t) {
        if (null == t && null != e.properties) {
            t = e.properties;
        } else if (null === t) {
            return void console.warn("Selected feature has no properties, cannot show any side panel content!");
        }
        let a = getName(t);
        if (null == a) {
            a = e.hasOwnProperty("id") && "object" != typeof e.id ? "Feature " + e.id : "NTU Power Network Visualisation";
        }

        this.panelHandler.setTitle("<h3>" + a + "</h3>");
        document.getElementById("titleContainer").classList.add("clickable");

        let n = t.description;
        if (null === n && t.desc) {
            n = t.desc;
        }

        if (null !== n && void 0 !== n) {
            this.panelHandler.setContent("<div class='description'>" + n + "</div>");
        } else {
            this.panelHandler.setContent("");
        }

        this.panelHandler.addSupportingData(e, t);

        let tButton = document.getElementById("treeButton");
        let iButton = document.getElementById("timeButton");

        if (void 0 === n && null === tButton && null === iButton) {
            this.panelHandler.setContent("<div class='description'>No data is available for this location.</div>");
        }

        $("#sidePanelInner").tabs("option", "active", 0);
        document.getElementById("returnContainer").style.display = "table";

        window.currentFeature = e;
    }

    /**
    showFeature(e, t) {
        if (null == t && null != e.properties) t = e.properties;
        else if (null === t) return void console.warn("Selected feature has no properties, cannot show any side panel content!");
        let a = getName(t),
            n = (null == a && (a = e.hasOwnProperty("id") && "object" != typeof e.id ? "Feature " + e.id : "NTU Energy Consumption Visualisation"), this.panelHandler.setTitle("<h3>" + a + "</h2"), document.getElementById("titleContainer").classList.add("clickable"), t.description);
        null !== (n = null === n && t.desc ? t.desc : n) && void 0 !== n ? this.panelHandler.setContent("<div class='description'>" + n + "</div>") : this.panelHandler.setContent(""), this.panelHandler.addSupportingData(e, t);
        var t = document.getElementById("treeButton"),
            i = document.getElementById("timeButton");
        void 0 === n && null === t && null === i && this.panelHandler.setContent("<div class='description'>No data is available for this location.</div>"), $("#sidePanelInner").tabs("option", "active", 0), document.getElementById("returnContainer").style.display = "table", window.currentFeature = e
    }
    **/
    openMetaTab(e, t) {
        for (var a, n = document.getElementsByClassName("tabcontent"), i = 0; i < n.length; i++) n[i].style.display = "none";
        for (a = document.getElementsByClassName("tablinks"), i = 0; i < a.length; i++) a[i].className = a[i].className.replace(" active", "");
        document.getElementById(t).style.display = "block", document.getElementById(e).className += " active"
    }
    updateTimeseries(e) {
        this.panelHandler.updateTimeseries(e)
    }
    moveMapToFeature() {
        if (document.getElementById("titleContainer").classList.contains("clickable")) {
            let e = window.currentFeature;
            if (null == e) return;
            switch (Manager.PROVIDER) {
                case MapProvider.MAPBOX:
                    e = getCenter(e), MapHandler.MAP.easeTo({
                        center: e,
                        zoom: 16,
                        duration: 3e3,
                        essential: !0
                    });
                    break;
                case MapProvider.CESIUM:
                    CesiumUtils.flyToFeature(e)
            }
        }
    }
    moveMap() {
        var e = [document.getElementById("lngCell").value, document.getElementById("latCell").value];
        MapHandler.MAP.jumpTo({
            center: e
        }), this.controlHandler.editingCoords = !1, this.controlHandler.updateInfoPanel(null)
    }
    cancelSearch() {
        Manager.DATA_STORE.dataGroups.forEach(e => {
            e.flattenDown().forEach(e => {
                var t = e.source,
                    a = MapHandler.MAP.getStyle(),
                    t = (!t.definition.cluster || a.sources[t.id].cluster || (a.sources[t.id].cluster = !0, MapHandler.MAP.setStyle(a)), e.definition.filter);
                null != t ? MapHandler.MAP.setFilter(e.id, t) : MapHandler.MAP.setFilter(e.id, null)
            })
        })
    }
    updateSearch(e) {
        let l = e.value.toLowerCase();
        Manager.DATA_STORE.dataGroups.forEach(e => {
            e.flattenDown().forEach(e => {
                var t = e.source,
                    a = ["all", ["has", "name"],
                        ["in", l, ["downcase", ["get", "name"]]]
                    ];
                let n = a;
                var i, r = e.definition.filter;
                null != r && (this.filterMatch(r, ["has", "point_count"]) || this.filterMatch(r, ["has", "point_count_abbreviated"]) ? (n = ["has", "nonsense-string"], (i = MapHandler.MAP.getStyle()).sources[t.id].cluster = !1, MapHandler.MAP.setStyle(i)) : n = this.filterMatch(r, ["!", ["has", "point_count"]]) || this.filterMatch(r, ["!", ["has", "point_count_abbreviated"]]) ? a : ["all", r, n]), null !== n && MapHandler.MAP.setFilter(e.id, n)
            })
        })
    }
    filterMatch(e, t) {
        return JSON.stringify(e) === JSON.stringify(t)
    }
    static findStack(e, t) {
        switch (Manager.PROVIDER) {
            case MapProvider.CESIUM:
                if (e instanceof Cesium.Cesium3DTileFeature) {
                    var a = e.tileset;
                    if (!a.hasOwnProperty("layerID")) return null;
                    var n, i, r = a.layerID;
                    for ([n, i] of Object.entries(Manager.STACK_LAYERS))
                        if (i.includes(r)) return n
                } else if (e.hasOwnProperty("primitive") && e.primitive instanceof Cesium.Cesium3DTileset) {
                    a = e.primitive;
                    if (!a.hasOwnProperty("layerID")) return null;
                    var l, s, o = a.layerID;
                    for ([l, s] of Object.entries(Manager.STACK_LAYERS))
                        if (s.includes(o)) return l
                } else if (e instanceof Cesium.ImageryLayerFeatureInfo) {
                    a = e.imageryLayer.imageryProvider;
                    if (!a.hasOwnProperty("layerID")) return null;
                    var d, u, c = a.layerID;
                    for ([d, u] of Object.entries(Manager.STACK_LAYERS))
                        if (u.includes(c)) return d
                } else {
                    a = e.id;
                    if (null != a) {
                        a = a.entityCollection.owner;
                        if (null != a && a.hasOwnProperty("layerID")) {
                            var p, m, h = a.layerID;
                            for ([p, m] of Object.entries(Manager.STACK_LAYERS))
                                if (m.includes(h)) return p
                        }
                    }
                }
                break;
            case MapProvider.MAPBOX:
                var y = e.layer.id;
                if (null != y)
                    for (var [g, M] of Object.entries(Manager.STACK_LAYERS))
                        if (M.includes(y)) return g
        }
        return null
    }
}
Manager.DATA_STORE = new DataStore, Manager.STACK_LAYERS = {};
class MapHandler {
    constructor(e) {
        this.manager = e
    }
}
var MapProvider;

function openHelpURL() {
    let t = null;
    var e, a = document.getElementsByTagName("script");
    for (let e = 0; e < a.length; e++) a[e].src.endsWith("dtvf.min.js") && (t = a[e].src);
    null !== t && ((e = t.toString().split("/"))[e.length - 1] = "help", e = e.join("/") + "/", window.open(e, "_blank"))
}

function getCenter(e) {
    e = turf.feature(e.geometry), e = turf.featureCollection([e]);
    return turf.center(e).geometry.coordinates
}
async function loadHTML(e) {
    return fetch(e).then(e => e.text())
}

function getDefaultImagery() {
    var e = Manager.SETTINGS.getSetting("imagery");
    return e[e.default]
}

function updateURL(e) {
    return e
}

function filterNulls(e) {
    var t, a = {};
    for (t in e) {
        var n = e[t];
        null !== n && (a[t] = n)
    }
    return a
}

function getName(e) {
    var t;
    return null == e ? null : null == (t = Manager.SETTINGS.getSetting("fields")) || null == (t = t.name) ? e.name : e[t]
}

function getDescription(e) {
    var t = Manager.SETTINGS.getSetting("fields");
    return null == t || null == (t = t.description) ? e.description : e[t]
}

function showAttributions() {
    let n = document.getElementById("attributionContainer");
    null == n && ((n = document.createElement("div")).id = "attributionContainer", n.className = "collapsed", n.innerHTML = "<div id='attributionTitle'><span>Attributions</span><i class='fas fa-chevron-up'></i></div>", document.body.appendChild(n));
    var e = Manager.SETTINGS.getSetting("attribution");
    if (n.style.display = null == e ? "none" : "block", null != e) {
        n.innerHTML += e;
        let a = n.querySelector("#attributionTitle");
        a.addEventListener("click", function(e) {
            var t = n.classList;
            t.contains("collapsed") ? (t.remove("collapsed"), t.add("expanded"), a.innerHTML = "<span>Attributions</span><i class='fas fa-chevron-down'></i>") : (t.remove("expanded"), t.add("collapsed"), a.innerHTML = "<span>Attributions</span><i class='fas fa-chevron-up'></i>")
        })
    }
}

function showHelpPage() {
    switch (Manager.PROVIDER) {
        case MapProvider.CESIUM:
        case MapProvider.MAPBOX:
    }
}
MapHandler.MAP_USER = "cmclinnovations", MapHandler.ALLOW_CLICKS = !0,
    function(e) {
        e[e.MAPBOX = 0] = "MAPBOX", e[e.CESIUM = 1] = "CESIUM"
    }(MapProvider = MapProvider || {});
class ControlHandler {
    constructor() {
        this.editingCoords = !1, window.terrain = "light", this.treeHandler = new TreeHandler
    }
    setupCollapses() {
        document.getElementById("controlContainer").querySelectorAll(".controlTitle p").forEach(t => {
            t.addEventListener("click", function() {
                var e = t.parentElement.parentElement;
                e.classList.contains("collapsed") ? e.classList.remove("collapsed") : e.classList.add("collapsed")
            })
        })
    }
    showControls() {
        this.setupCollapses(), this.generateImageryOptions()
    }
    rebuildTree(e) {
        this.treeHandler.rebuild(e)
    }
    showInfoPanel() {
        document.getElementById("developerContainer").style.display = "block !important";
        let t = this;
        MapHandler.MAP.on("mousemove", function(e) {
            t.updateInfoPanel(e)
        })
    }
    updateInfoPanel(a) {
        if (!this.editingCoords) {
            document.getElementById("developerContainer").style.display = "block";
            let e, t;
            null == a ? (e = document.getElementById("lngCell").innerHTML, t = document.getElementById("latCell").innerHTML) : null !== a.lngLat && (e = a.lngLat.lng.toFixed(5), t = a.lngLat.lat.toFixed(5)), document.getElementById("coordsContainer").innerHTML = `
			<table class="infoContainer" style="width: 100%; table-layout: fixed;">
				<tr>
                    <td width="60%">Longitude (at cursor):</td>
					<td width="40%" id="lngCell">` + e + `</td>
				</tr>
				<tr>
                    <td width="60%">Latitude (at cursor):</td>
					<td width="40%" id="latCell">` + t + `</td>
				</tr>
			</table>
		`
        }
    }
    editInfoPanel() {
        var e = document.getElementById("lngCell").innerHTML,
            t = document.getElementById("latCell").innerHTML;
        document.getElementById("coordsContainer").innerHTML = `
			<table class="infoContainer" style="pafdding-top: 5px; width: 100%; table-layout: fixed;">
				<tr>
					<td width="50%">Map longitude:</td>
					<td width="50%"><input id="lngCell" type="number" style="width: 100%;" value="` + e + `"></input></td>
				</tr>
				<tr>
					<td width="50%">Map latitude:</td>
					<td width="50%"><input id="latCell" type="number" style="width: 100%;" value="` + t + `"></input></td>
				</tr>
                <tr>
                    <td width="50%"></td>
					<td width="50%"><button style="width: 100%;" onclick="manager.moveMap()">Apply</button></td>
				</tr>
			</table>
		`, this.editingCoords = !0
    }
    generateImageryOptions() {
        let a = document.getElementById("imageryContainer");
        var e = Manager.SETTINGS.getSetting("imagery");
        let n = e.default;
        Object.keys(e).forEach(function(t) {
            if ("default" !== t) {
                let e = '<input type="radio" name="terrain" id="' + t + '"';
                switch (Manager.PROVIDER) {
                    case MapProvider.MAPBOX:
                        e += ' onclick="MapboxUtils.changeTerrain(this.id)"';
                        break;
                    case MapProvider.CESIUM:
                        e += ' onclick="CesiumUtils.changeTerrain(this.id)"'
                }
                e += t === n ? " checked>" : ">";
                t = '<label for="' + t + '">' + t + "</label><br/>";
                a.innerHTML += e + t
            }
        })
    }
}
class JSONFormatter {
    static formatJSON(e) {
        e = JSON.stringify(e);
        return JSON.parse(e, function(e, t) {
            var a, n;
            if ("string" == typeof e && "string" == typeof t) return a = JSONFormatter.formatKey(e), n = JSONFormatter.formatValue(t), this[a] = n, a === e ? n : void 0;
            return t
        })
    }
    static formatKey(e) {
        let t = e;
        return t = (t = t.includes('"') ? t.replaceAll('"', "") : t).endsWith(".") ? t.substring(0, e.length - 1) : t
    }
    static formatValue(e) {
        let t = e;
        if (t.startsWith("{") || t.startsWith("[")) try {
            return JSON.parse(t)
        } catch (e) {}
        var a;
        return (t = (t = t.includes("Â") ? t.replaceAll("Â", "") : t).includes('"') ? t.replaceAll('"', "") : t).includes("^^") && (t = t.split("^^")[0]), e.includes("[") && e.includes("]") && !t.includes("[") && !t.includes("]") && (a = new RegExp("(?<=\\[).*(?=\\])"), e = e.match(a), t = t.trim() + " [" + e + "]"), t
    }
}
var SEARCH_TYPE, JsonView = function(e) {
    "use strict";

    function d(e) {
        return (d = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function t(e) {
        0 < e.children.length && (e = e.el.querySelector(".fas")) && e.classList.replace("fa-caret-right", "fa-caret-down")
    }

    function a(e) {
        0 < e.children.length && (e = e.el.querySelector(".fas")) && e.classList.replace("fa-caret-down", "fa-caret-right")
    }

    function n(e) {
        (e.isExpanded ? (e.isExpanded = !1, a(e), function t(e) {
            e.children.forEach(function(e) {
                e.el.classList.add("hide"), e.isExpanded && t(e)
            })
        }) : (e.isExpanded = !0, t(e), function t(e) {
            e.children.forEach(function(e) {
                e.el.classList.remove("hide"), e.isExpanded && t(e)
            })
        }))(e)
    }

    function i(e) {
        var t = document.createElement("div"),
            t = (0 < e.children.length ? (t.innerHTML = function(e) {
                var e = 0 < arguments.length && void 0 !== e ? e : {},
                    t = e.key,
                    e = e.size;
                return '\n    <div class="line">\n      <div class="caret-icon"><i class="fas fa-caret-right"></i></div>\n      <div class="json-key">'.concat(t, '</div>\n      <div class="json-size">').concat(e, "</div>\n    </div>\n  ")
            }({
                key: e.key,
                size: ""
            }), t.querySelector(".caret-icon").addEventListener("click", function() {
                n(e)
            })) : t.innerHTML = function(e) {
                var e = 0 < arguments.length && void 0 !== e ? e : {},
                    t = e.key,
                    a = e.value,
                    e = e.type;
                return '\n    <div class="line">\n      <div class="empty-icon"></div>\n      <div class="json-key">'.concat(t, '</div>\n      <div class="json-separator">:</div>\n      <div class="json-value json-').concat(e, '">').concat(a, "</div>\n    </div>\n  ")
            }({
                key: e.key,
                value: e.value,
                type: d(e.value)
            }), t.children[0]);
        return null !== e.parent && t.classList.add("hide"), t.style = "margin-left: " + 18 * e.depth + "px;", t
    }

    function u(e) {
        var t = d(e);
        return Array.isArray(e) && (t = "array"), t = null === e ? "null" : t
    }

    function r(e, t) {
        t(e), 0 < e.children.length && e.children.forEach(function(e) {
            r(e, t)
        })
    }

    function c(e) {
        e = 0 < arguments.length && void 0 !== e ? e : {};
        return {
            key: e.key || null,
            parent: e.parent || null,
            value: e.hasOwnProperty("value") ? e.value : null,
            isExpanded: e.isExpanded || !1,
            type: e.type || null,
            children: e.children || [],
            el: e.el || null,
            depth: e.depth || 0,
            collapse: e.collapse || !1
        }
    }

    function l(e, t = "All Entries:") {
        e = "string" == typeof e ? JSON.parse(e) : e, t = c({
            value: e,
            key: t,
            type: u(e)
        });
        return function a(n, i) {
            if ("object" === d(n)) {
                var r, l = "display_order",
                    s = "value";
                let t = [],
                    e = (l in n ? t = n[l] : Object.keys(n).forEach(e => {
                        "collapse" !== e && t.push(e)
                    }), !1);
                "collapse" in n && (e = n.collapse);
                for (r of t)
                    if (Object.keys(n[r]).includes(s)) {
                        let e = [];
                        e = "number" == typeof n[r][s] ? n[r][s].toFixed(2) : n[r][s], "unit" in n[r] && (e += " " + n[r].unit);
                        var o = c({
                            value: e,
                            key: r,
                            depth: i.depth + 1,
                            type: u(n[r]),
                            parent: i
                        });
                        i.children.push(o), a(e, o)
                    } else o = c({
                        value: n[r],
                        key: r,
                        depth: i.depth + 1,
                        type: u(n[r]),
                        parent: i,
                        collapse: e
                    }), i.children.push(o), a(n[r], o)
            }
        }(e, t), t
    }

    function s(e, t) {
        (a = document.createElement("div")).className = "json-container";
        var a, n = a;
        r(e, function(e) {
            e.el = i(e), n.appendChild(e.el)
        }), t.appendChild(n)
    }

    function o(t) {
        r(t, function(e) {
            e.isExpanded = !1, e.depth > t.depth && e.el.classList.add("hide"), a(e)
        })
    }
    return e.collapseChildren = o, e.createTree = l, e.expandChildren = function(e) {
        r(e, function(e) {
            e.el.classList.remove("hide"), e.isExpanded = !0, t(e)
        })
    }, e.render = s, e.renderJSON = function(e, t, a = "All Entries:") {
        let n = e;
        return s(e = l("string" == typeof(n = Array.isArray(e) && 1 === e.length ? e[0] : n) ? JSON.parse(n) : n, a), t), e
    }, e.traverseTree = r, e.selectiveCollapse = function t(e) {
        0 < e.children.length && !e.collapse ? e.children.forEach(e => {
            t(e)
        }) : o(e)
    }, e
}({});
class PanelHandler {
    constructor(e) {
        this.manager = e, this.timeseriesHandler = new TimeseriesHandler
    }
    toggleLegend(e) {
        document.getElementById("legendContainer").style.display = e ? "block" : "none"
    }
    setTitle(e) {
        document.getElementById("sidePanel").style.visibility = "visible", document.getElementById("titleContainer").innerHTML = e
    }
    setContent(e) {
        document.getElementById("sidePanel").style.visibility = "visible", document.getElementById("contentContainer").innerHTML = e, document.getElementById("sidePanel").classList.contains("large") && (document.getElementById("controlsParent").style.visibility = "hidden")
    }
    appendContent(e) {
        document.getElementById("sidePanel").style.visibility = "visible", document.getElementById("contentContainer").innerHTML += e
    }
    setLegend(e) {
        document.getElementById("sidePanel").style.visibility = "visible", document.getElementById("sidePanelLegend").innerHTML = e
    }
    setFooter(e) {
        document.getElementById("sidePanel").style.visibility = "visible", document.getElementById("footerContainer").innerHTML = e
    }
    storeDefault() {
        this._defaultHTML = document.getElementById("sidePanelGeneral").innerHTML
    }
    returnToDefault() {
        null != this._defaultHTML && (document.getElementById("sidePanelGeneral").innerHTML = this._defaultHTML), document.getElementById("returnContainer").style.display = "none", window.currentFeature = null, $("#sidePanelInner").tabs("option", "active", 0)
    }
    toggleMode() {
        var e = document.getElementById("sidePanel"),
            t = document.getElementById("slideButton"),
            a = document.getElementById("expandButton"),
            n = document.getElementById("attributionContainer");
        e.classList.contains("small") ? (e.classList.replace("small", "large"), a.classList.replace("fa-expand", "fa-compress"), document.getElementById("map").style.width = "100%", document.getElementById("controlsContainer").style.visibility = "hidden", t.style.visibility = "hidden", null != n && (n.style.display = "none")) : e.classList.contains("large") && (e.classList.replace("large", "small"), a.classList.replace("fa-compress", "fa-expand"), document.getElementById("map").style.width = "calc(100% - 500px)", document.getElementById("controlsContainer").style.visibility = "visible", t.style.visibility = "visible", null != Manager.SETTINGS.getSetting("attribution")) && null != n && (n.style.display = "block"), MapHandler.MAP.resize()
    }
    toggleExpansion() {
        var e = document.getElementById("sidePanel"),
            t = document.getElementById("sidePanelInner"),
            a = document.getElementById("slideButton"),
            n = document.getElementById("expandButton"),
            i = document.getElementById("finderContainer");
        e.classList.contains("small") && (e.classList.contains("collapsed") ? (e.classList.replace("collapsed", "expanded"), a.classList.replace("fa-chevron-left", "fa-chevron-right"), document.getElementById("map").style.width = "calc(100% - 500px)", n.style.visibility = "visible", t.style.visibility = "visible", null != i && (i.style.width = "calc(100% - 540px)")) : e.classList.contains("expanded") && (e.classList.replace("expanded", "collapsed"), a.classList.replace("fa-chevron-right", "fa-chevron-left"), document.getElementById("map").style.width = "calc(100% - 28px)", n.style.visibility = "hidden", t.style.visibility = "hidden", null != i) && (i.style.width = "calc(100% - 80px)")), MapHandler.MAP.resize()
    }

    addSupportingData(e, a) {
        a = filterNulls(a);
        let t = a.endpoint;
        let n = a.iri;

        this.prepareMetaContainers(true, true);
        document.getElementById("metaTreeContainer").innerHTML = "<i>Retrieving data...</i>";

        const keys = Object.keys(a);
        keys.forEach(key => {
            console.log(`Property: ${key}, Value: ${a[key]}`);
        });

        console.warn("a: ", a);
        console.warn("filtered a: ", filterNulls(a));
        console.warn(Object.keys(a)[0]);
        console.warn(a[Object.keys(a)[0]]);

        let i = this;
        let iriValue;
        // check whether the user is clicking on a connection line
        if(Object.keys(a)[0] === "0"){
            if (a[Object.keys(a)[0]] === "1"){
                if (Object.keys(a)[1] === "1"){
                    //double digits
                    if(a[Object.keys(a)[1]] === "0"){
                        //10
                        iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Branch_" + a[Object.keys(a)[0]] + a[Object.keys(a)[1]];
                    }
                    else if(a[Object.keys(a)[1]] === "1"){
                        //11
                        iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Branch_" + a[Object.keys(a)[0]] + a[Object.keys(a)[1]];
                    }
                    else if(a[Object.keys(a)[1]] === "2"){
                        //12
                        iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Branch_" + a[Object.keys(a)[0]] + a[Object.keys(a)[1]];
                    }
                    else if(a[Object.keys(a)[1]] === "3"){
                        //13
                        iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Branch_" + a[Object.keys(a)[0]] + a[Object.keys(a)[1]];
                    }
                }
            }
            else{
                //single digit
                if(a[Object.keys(a)[0]] === "0"){
                    //0
                    iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Branch_" + a[Object.keys(a)[0]];
                }
                else if(a[Object.keys(a)[0]] === "1"){
                    //1
                    iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Branch_" + a[Object.keys(a)[0]];
                }
                else if(a[Object.keys(a)[0]] === "2"){
                    //2
                    iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Branch_" + a[Object.keys(a)[0]];
                }
                else if(a[Object.keys(a)[0]] === "3"){
                    //3
                    iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Branch_" + a[Object.keys(a)[0]];
                }
                if(a[Object.keys(a)[0]] === "4"){
                    //4
                    iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Branch_" + a[Object.keys(a)[0]];
                }
                else if(a[Object.keys(a)[0]] === "5"){
                    //5
                    iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Branch_" + a[Object.keys(a)[0]];
                }
                else if(a[Object.keys(a)[0]] === "6"){
                    //6
                    iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Branch_" + a[Object.keys(a)[0]];
                }
                else if(a[Object.keys(a)[0]] === "7"){
                    //7
                    iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Branch_" + a[Object.keys(a)[0]];
                }
                else if(a[Object.keys(a)[0]] === "8"){
                    //8
                    iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Branch_" + a[Object.keys(a)[0]];
                }
                else if(a[Object.keys(a)[0]] === "9"){
                    //9
                    iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Branch_" + a[Object.keys(a)[0]];
                }
            }

        }
        else{
            if (a.id === 120) {
                iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Building_SBS";
            } else if (a.id === 40) {
                iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Building_N1_3";
            } else if (a.id === 442) {
                iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Building_NYA";
            } else if (a.id === 47) {
                iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Building_N_2";
            } else if (a.id === 454) {
                iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Building_N_2_1";
            } else if (a.id === 488) {
                iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Building_SPMS";
            } else if (a.id === 17) {
                iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Building_HALL_4";
            } else if (a.id === 387) {
                iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Building_PIONEER_HALL";
            } else if (a.id === 277) {
                iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Building_THE_WAVE";
            } else if (a.id === 190) {
                iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Building_CANTEEN_2";
            } else if (a.id === 1) {
                iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Building_EMB";
            } else if (a.id === 92) {
                iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Building_RTP";
            } else if (a.id === 399) {
                iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Building_NEC";
            }
            else {
                iriValue = a.id;
            }
        }

        console.warn("id type: ", typeof a.id);
        return $.getJSON("http://localhost:3838/feature-info-agent/get", {
            iri: iriValue
        }, function(e) {
            let t;
            if (e === null || Array.isArray(e) && e.length === 0 || Object.keys(e).length === 0) {
                i.showBuiltInData(a);
            } else {
                t = e.meta;
                e = e.time;
                if (t !== null) {
                    console.log("Got a meta object!");
                }
                if (e !== null) {
                    console.log("Got a time object!");
                }

                document.getElementById("metaTreeContainer").innerHTML = "";
                if (t !== null) {
                    t = JSONFormatter.formatJSON(t);
                    if (document.getElementById("metaTreeContainer") === null) {
                        console.log("TREE CONTAINER IS NULL, WHAT?!");
                    }

                    if (Array.isArray(t) && t.length === 0 || typeof t === 'string' && t === '') {
                        this.showBuiltInData(a);
                    } else {
                        t = JsonView.renderJSON(t, document.getElementById("metaTreeContainer"));
                        JsonView.expandChildren(t);
                        JsonView.selectiveCollapse(t);
                    }
                } else {
                    i.showBuiltInData(a);
                }

                document.getElementById("metaTimeContainer").innerHTML = "";
                if (e !== null) {
                    i.timeseriesHandler.parseData(e);
                    i.timeseriesHandler.showData("metaTimeContainer");
                    document.getElementById("time-series-select").onchange(null);
                } else {
                    console.warn("No 'time' node found, skipping timeseries visualisation.");
                }
                i.prepareMetaContainers(true, e !== null);
            }
        }).fail(function() {
            console.warn("Could not get valid response from the agent, will show any in-model content instead...");
            i.showBuiltInData(a);
        });
    }

    /**
    addSupportingData(e, a) {
        var t = (a = filterNulls(a)).endpoint,
            n = a.iri;
        this.prepareMetaContainers(!0, !0), document.getElementById("metaTreeContainer").innerHTML = "<i>Retrieving data...</i>";
        const keys = Object.keys(a);
        keys.forEach(key => {
            console.log(`Property: ${key}, Value: ${a[key]}`);
        });
        console.warn("a: "+a);
        console.warn("filtered a: "+filterNulls(a));
        let i = this;

        let iriValue;

        if (a.id === 120) {
            iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Building_SBS";
        } else if (a.id === 40) {
            iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Building_N1_3";
        } else if (a.id === 442) {
            iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Building_NYA";
        } else if (a.id === 47) {
            iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Building_N_2";
        } else if (a.id === 454) {
            iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Building_N_2_1";
        } else if (a.id === 488) {
            iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Building_SPMS";
        } else if (a.id === 17) {
            iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Building_HALL_4";
        } else if (a.id === 387) {
            iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Building_PIONEER_HALL";
        } else if (a.id === 277) {
            iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Building_THE_WAVE";
        } else if (a.id === 190) {
            iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Building_CANTEEN_2";
        } else if (a.id === 1) {
            iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Building_EMB";
        } else if (a.id === 92) {
            iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Building_RTP";
        } else if (a.id === 399) {
            iriValue = "https://www.theworldavatar.com/kg/ontopowsys/NTU_Building_NEC";
        }
        else {
            iriValue = a.id;
        }
        console.warn("id type: "+typeof a.id);

        return $.getJSON("http://localhost:3838/feature-info-agent/get", {
            iri: iriValue
        }, function(e) {
            var t;
            null == e || Array.isArray(e) && 0 == e.length || 0 == Object.keys(e).length ? i.showBuiltInData(a) : (t = e.meta, e = e.time, null != t && console.log("Got a meta object!"), null != e && console.log("Got a time object!"), document.getElementById("metaTreeContainer").innerHTML = "", null != t ? (t = JSONFormatter.formatJSON(t), null == document.getElementById("metaTreeContainer") && console.log("TREE CONTAINER IS NULL, WHAT?!"), Array.isArray(t) && 0 === t.length || "string" == typeof t && "" === t ? this.showBuiltInData(a) : (t = JsonView.renderJSON(t, document.getElementById("metaTreeContainer")), JsonView.expandChildren(t), JsonView.selectiveCollapse(t))) : i.showBuiltInData(a), document.getElementById("metaTimeContainer").innerHTML = "", null != e ? (i.timeseriesHandler.parseData(e), i.timeseriesHandler.showData("metaTimeContainer"), document.getElementById("time-series-select").onchange(null)) : console.warn("No 'time' node found, skipping timeseries visualisation."), i.prepareMetaContainers(!0, null != e))
        }).fail(function() {
            console.warn("Could not get valid response from the agent, will show any in-model content instead..."), i.showBuiltInData(a)
        })
    }
    **/
    showBuiltInData(e) {
        this.prepareMetaContainers(!0, !1), document.getElementById("metaTreeContainer").innerHTML = "", 0 < Object.keys(e).length ? (e = JSONFormatter.formatJSON(e), e = JsonView.renderJSON(e, document.getElementById("metaTreeContainer")), JsonView.expandChildren(e), JsonView.selectiveCollapse(e)) : document.getElementById("metaTreeContainer").innerHTML = "<i>No available data.</i>"
    }
    updateTimeseries(e) {
        this.timeseriesHandler.update(e)
    }
    prepareMetaContainers(e, t) {
        var a = document.getElementById("metaTabs"),
            a = (null == a && this.appendContent("<div id='metaTabs'></div>"), document.getElementById("metaContainer"));
        null == a && this.appendContent("<div id='metaContainer'></div>");
        let n = document.getElementById("treeButton"),
            i = document.getElementById("timeButton");
        e && (null === n && (document.getElementById("metaTabs").innerHTML += `
                    <button id="treeButton" class="tablinks" onclick="manager.openMetaTab(this.id, 'metaTreeContainer')">Metadata</button>
                `, n = document.getElementById("treeButton")), null === document.getElementById("metaTreeContainer")) && (document.getElementById("metaContainer").innerHTML += "<div id='metaTreeContainer' class='tabcontent'></div>"), t && (null === i && (document.getElementById("metaTabs").innerHTML += `
                    <button id="timeButton" class="tablinks" onclick="manager.openMetaTab(this.id, 'metaTimeContainer')">Time Series</button>
                `, i = document.getElementById("timeButton")), null === document.getElementById("metaTimeContainer")) && (document.getElementById("metaContainer").innerHTML += "<div id='metaTimeContainer' style='display: none;' class='tabcontent'></div>"), null != n && (n.style.display = e ? "block" : "none"), null != i && (i.style.display = t ? "block" : "none"), e && !t ? (n.style.width = "100%", n.style.borderRadius = "10px", this.manager.openMetaTab("treeButton", "metaTreeContainer")) : !e && t ? (i.style.width = "100%", i.style.borderRadius = "10px", this.manager.openMetaTab("timeButton", "metaTimeContainer")) : e && t && (n.style.width = "50%", n.style.borderRadius = "10px 0 0 10px", this.manager.openMetaTab("treeButton", "metaTreeContainer"));
        a = document.getElementById("footerContainer");
        null !== a && (a.style.display = "none")
    }
    addLinks(e) {
        return $.getJSON(e, function(e) {
            return e
        }).fail(() => {
            console.warn("Could not read links.json, skipping.");
            var e = document.querySelector('li[aria-controls="sidePanelLinks"]');
            null !== e && (e.style.display = "none")
        }).done(t => {
            var e;
            if (null !== t && t.links) {
                var a = document.getElementById("sidePanelLinks");
                if (null !== a && (a.innerHTML += "<br/><br/>", t.intro && (a.innerHTML += "<p>" + t.intro + "</p>"), t.links)) {
                    a.innerHTML += "<ul>";
                    for (let e = 0; e < t.links.length; e++) {
                        var n = t.links[e];
                        a.innerHTML += "<li><a href='" + n.url + "' target='_blank'>" + n.text + "</a></li>"
                    }
                    a.innerHTML += "</ul>"
                }
            } else null !== (e = document.querySelector('li[aria-controls="sidePanelLinks"]')) && (e.style.display = "none")
        })
    }
}
class SearchHandler {
    constructor() {
        this.allSearchProperties = Manager.SETTINGS.getSetting("search"), this.generateControls()
    }
    toggle() {
        var e, t = document.getElementById("finderContainer");
        null != t && (e = document.getElementById("attributionContainer"), "table" === t.style.display ? null != e && null != Manager.SETTINGS.getSetting("attribution") && (e.style.display = "block") : (t.style.display = "table", null != e && (e.style.display = "none"), this.turnOffClustering()), null != (e = document.getElementById("sidePanel"))) && (e.classList.contains("expanded") ? t.style.width = "calc(100% - 540px)" : t.style.width = "calc(100% - 80px)")
    }
    generateControls() {
        let e = this;
        var t = document.getElementById("finderContainer");
        if (null === t) {
            (t = document.createElement("div")).id = "finderContainer", t.style.display = "none";
            var n = document.createElement("label");
            n.id = "finderLabel", n.innerHTML = "Find locations where", t.appendChild(n);
            let a = document.createElement("select");
            a.id = "finderSelect", a.classList.add("finderSelectClass"), this.allSearchProperties.forEach(e => {
                var t = document.createElement("option");
                t.classList.add("finderSelectClass"), t.value = e.property, t.text = e.description, a.appendChild(t)
            });
            var n = document.createElement("div"),
                i = (n.classList.add("tooltip"), n.classList.add("searchButton"), n.addEventListener("click", () => {
                    this.cancelSearch();
                    document.getElementById("finderContainer").style.display = "none";
                    var e = document.getElementById("attributionContainer");
                    null != e && null != Manager.SETTINGS.getSetting("attribution") && (e.style.display = "block"), this.turnOnClustering()
                }), n.innerHTML = "<span class='tooltiptext lower'>Cancel search</span>", document.createElement("i"));
            i.classList.add("far"), i.classList.add("fa-window-close"), i.classList.add("fa-lg"), n.appendChild(i), a.addEventListener("change", function() {
                e.changeProperty(a.value), e.startSearch()
            }), t.appendChild(a), t.appendChild(n), document.body.appendChild(t), a.dispatchEvent(new Event("change"))
        }
    }
    changeProperty(t) {
        let e = this;
        var a = document.getElementById("finderContainer");
        this.allSearchProperties.forEach(e => {
            e.property === t && (this.property = e)
        });
        let n = document.getElementById("finderRangeSelect"),
            i = (null !== n && void 0 !== n || ((n = document.createElement("select")).id = "finderRangeSelect", n.classList.add("finderSelectClass"), n.addEventListener("change", function() {
                e.startSearch()
            }), a.appendChild(n)), document.getElementById("finderField"));
        switch (this.property.type.toLowerCase()) {
            case "string":
                n.innerHTML = `
                    <option value="contains">contains</option>
                    <option value="starts">starts with</option>
                `, null !== i && void 0 !== i || ((i = document.createElement("input")).id = "finderField", a.appendChild(i)), i.style.display = "table-cell", i.type = "text", i.value = "", i.placeholder = "search term", i.addEventListener("input", function() {
                    e.startSearch()
                });
                break;
            case "number":
                n.innerHTML = `
                    <option value="equals">equals</option>
                    <option value="lesser">is lesser than</option>
                    <option value="greater">is greater than</option>
                `, null !== i && void 0 !== i || ((i = document.createElement("input")).id = "finderField", a.appendChild(i)), i.style.display = "table-cell", i.type = "number", i.value = "0", i.placeholder = "search term";
                break;
            case "boolean":
                n.innerHTML = `
                    <option value="true">is true</option>
                    <option value="false">is false</option>
                `, null !== i && void 0 !== i && (i.style.display = "none")
        }
        null !== i && void 0 !== i && i.focus()
    }
    startSearch() {
        switch (this.property.type) {
            case "string":
            case "number":
                var e = document.getElementById("finderField");
                null != e && (e = e.value, this.runSearch(e));
                break;
            case "boolean":
                "true" === document.getElementById("finderRangeSelect").value ? this.runSearch(!0) : this.runSearch(!1)
        }
    }
}! function(e) {
    e[e.STRING = 0] = "STRING", e[e.NUMBER = 1] = "NUMBER", e[e.BOOLEAN = 2] = "BOOLEAN"
}(SEARCH_TYPE = SEARCH_TYPE || {});
class TimeseriesHandler {
    parseData(e) {
        this._selectedData = [];
        let t = JSONFormatter.formatJSON(e);
        Array.isArray(t) || ((e = []).push(t), t = e);
        for (var a = 0; a < t.length; a++) {
            var n = t[a];
            if (null != n && n.data && n.units && n.time && n.values)
                for (var i = n.data, r = n.units, l = 0; l < i.length; l++) {
                    for (var s = i[l], o = r[l], d = (s += " [" + o + "]", n.time), u = null, c = d[0], p = String(c).match(/^\d{4}-\d{2}-\d{2}T\d{2}(:\d{2}){1,2}Z/), m = String(c).match(/^\d{4}-\d{2}-\d{2}\s\d{2}(:\d{2}){1,2}/), u = p || m ? "dateTime" : String(c).includes(":") ? "offsetTime" : "number", h = 0; h < d.length; h++) "dateTime" === u ? d[h] = moment(d[h], "YYYY-MM-DDTHH:mm:ss").format("YYYY-MM-DD HH:mm:ss") : "offsetTime" === u && (d[h] = moment(d[h], "HH:mm:ss").format("HH:mm:ss"));
                    p = n.values[l];
                    this._selectedData.push({
                        name: s,
                        id: this._selectedData.length,
                        unit: o,
                        times: d,
                        values: p,
                        timeClass: u,
                        valuesClass: n.valuesClass ? n.valuesClass[l] : "Number"
                    })
                }
        }
        console.log(this._selectedData)
    }
    showData(e) {
        var t = this.buildComboBox();
        document.getElementById(e).innerHTML = `
            <div id="time-series-control">
                ` + t + `
            </div>
            <div id="time-series-chart-container">
                <canvas id="chart-canvas"></canvas>
            </div>
            <div id="time-series-table-container">
            </div>
        `
    }
    updateTable(e) {
        document.getElementById("time-series-table-container").innerHTML = this.buildTable(e)
    }
    updateChart(e) {
        this.buildChart(e)
    }
    update(e) {
        this.updateTable(e), this.updateChart(e)
    }
    buildTable(t) {
        var a = null;
        if (this._selectedData.forEach(e => {
                null === a && e.id === +t && (a = e)
            }), null != a) {
            var e = a.times,
                n = a.values,
                i = '<table class="time-series-table" width="100%">';
            i += "<tr><th>Time</th><th>" + a.name + "</th></tr>";
            for (var r = 0; r < e.length; r++) i += `
                <tr>
                    <td width="50%">
                        ` + e[r] + `
                    </td>
                    <td width="50%">
                        ` + n[r] + `
                    </td>
                </tr>
            `;
            return i += "</table>"
        }
    }
    buildChart(t) {
        var a = null;
        if (this._selectedData.forEach(e => {
                null === a && e.id === +t && (a = e)
            }), null != a) {
            for (var e = [...a.times], n = [], i = 0; i < e.length; i++) "dateTime" === a.timeClass ? e[i] = moment(e[i], "YYYY-MM-DD HH:mm:ss") : "offsetTime" === a.timeClass && (e[i] = moment(e[i], "HH:mm:ss")), n.push({
                x: e[i],
                y: isNaN(a.values[i]) ? Number(a.values[i]) : a.values[i]
            });
            null != this._currentChart && this._currentChart.destroy();
            var r = document.getElementById("chart-canvas").getContext("2d"),
                l = "Boolean" === a.valuesClass ? "category" : "linear",
                s = "linear";
            "dateTime" !== a.timeClass && "offsetTime" !== a.timeClass || (s = "time"), this._currentChart = new Chart(r, {
                type: "line",
                options: {
                    responsive: !0,
                    maintainAspectRatio: !1,
                    plugins: {
                        legend: {
                            display: !1
                        }
                    },
                    scales: {
                        x: {
                            type: s,
                            distribution: "linear",
                            ticks: {
                                font: {
                                    weight: 400,
                                    size: 10
                                }
                            },
                            title: {
                                display: !0,
                                text: "Time",
                                font: {
                                    weight: 700,
                                    size: 12
                                }
                            }
                        },
                        y: {
                            type: l,
                            labels: [!0, !1],
                            ticks: {
                                font: {
                                    weight: 400,
                                    size: 10
                                }
                            },
                            title: {
                                display: !0,
                                text: a.name,
                                font: {
                                    weight: 700,
                                    size: 12
                                }
                            }
                        }
                    }
                },
                data: {
                    labels: e,
                    datasets: [{
                        label: a.name,
                        pointBorderColor: "rgba(33, 150, 243, 0.70)",
                        borderColor: "rgba(33, 150, 243, 0.35)",
                        data: n
                    }]
                }
            })
        }
    }
    buildComboBox() {
        var t = `
            <label for="time-series-select">Select a data set:</label>
            <select name="time-series-select" id="time-series-select" onchange="manager.updateTimeseries(this.value)">
        `;
        return this._selectedData.forEach(e => {
            t += `
                <option value="` + e.id + '">' + e.name + `</option>
            `
        }), t += "</select>"
    }
}
class TreeHandler {
    registerEvents(n) {
        $("#treeview").on("CheckUncheckDone", function() {
            var e = {
                id: [],
                dataid: [],
                text: []
            };
            $("#treeview").hummingbird("getChecked", {
                list: e,
                onlyEndNodes: !0
            });
            let t = [];
            e.dataid.forEach(e => {
                e.includes("|") ? e.split("|").forEach(e => t.push(e)) : t.push(e)
            });
            var a = DataUtils.getAllLayerIDs(n).filter(e => !t.includes(e));
            switch (Manager.PROVIDER) {
                case MapProvider.MAPBOX:
                    t.forEach(e => MapboxUtils.toggleLayer(e, !0)), a.forEach(e => MapboxUtils.toggleLayer(e, !1));
                    break;
                case MapProvider.CESIUM:
                    t.forEach(e => CesiumUtils.toggleLayer(e, !0)), a.forEach(e => CesiumUtils.toggleLayer(e, !1))
            }
        })
    }
    rebuild(e) {
        for (var t = document.getElementById("treeview"), a = (t.innerHTML = "", []), n = [], i = [], r = 0; r < e.dataGroups.length; r++) this.buildRecurse(i, e.dataGroups[r], 1, a, n);
        t.innerHTML += i.join(""), $.fn.hummingbird.defaults.SymbolPrefix = "fas", $.fn.hummingbird.defaults.collapsedSymbol = "fa-chevron-down", $.fn.hummingbird.defaults.expandedSymbol = "fa-chevron-up", $("#treeview").hummingbird(), $("#treeview").hummingbird("checkNode", {
            sel: "data-id",
            vals: a
        }), $("#treeview").hummingbird("expandAll"), $("#treeview").hummingbird("collapseNode", {
            sel: "data-id",
            vals: n
        }), this.registerEvents(e), console.log("Finished rebuilding layer tree.")
    }
    buildRecurse(e, t, a, n, i) {
        let r = "<li data-id='" + (a - 1) + "'>";
        r = (r = (r += "<i class='fa fa-plus'></i><label>") + "<input id='" + t.id + "' data-id='" + t.id + "' type='checkbox'/>") + t.name + "</label>";
        var l, s, o = 0 < t.dataLayers.length || 0 < t.subGroups.length;
        o && (r += "<ul>"), t.defaultExpanded || i.push(t.id);
        let d = {};
        t.dataLayers.forEach(e => {
            null !== d[e.name] && void 0 !== d[e.name] || (d[e.name] = []), d[e.name].push(e)
        });
        for ([l, s] of Object.entries(d)) {
            var u = s;
            let t = "",
                a = !0,
                e = (u.forEach(e => {
                    e.definition.hasOwnProperty("treeable") && !0 !== e.definition.treeable || (a = !1), t += e.id + "|"
                }), t.endsWith("|") && (t = t.slice(0, -1)), "<li class='end-node'");
            switch (a ? e += "style='display:none;'>" : e += ">", e = (e = (e = (e += "<label>") + ("<input class='hummingbird-end-node' id='" + t + "' data-id='" + t + "' type='checkbox'/><span>")) + l) + "</span></label>" + "</li>", r += e, Manager.PROVIDER) {
                case MapProvider.MAPBOX:
                    s[0].isVisible() && n.push(t);
                    break;
                case MapProvider.CESIUM:
                    var c = s[0],
                        p = MapHandler_Cesium.DATA_SOURCES[c.id];
                    null == p || 0 === p.length ? null != (p = c.definition.visibility) && "visible" !== p || n.push(t) : c.isVisible() && n.push(t)
            }
        }
        e.push(r);
        for (var m = 0; m < t.subGroups.length; m++) {
            var h = t.subGroups[m];
            this.buildRecurse(e, h, a + 1, n, i)
        }
        o && e.push("</ul>"), e.push("</li>")
    }
}
class IconHandler {
    async loadIcon(i, r) {
        await new Promise((a, n) => {
            MapHandler.MAP.loadImage(r, (e, t) => {
                e ? (console.log("ERROR: Could not load image at URL " + r), n(e)) : (MapHandler.MAP.addImage(i, t), a(t))
            })
        })
    }
}
class MapHandler_Mapbox extends MapHandler {
    constructor(e) {
        super(e)
    }
    initialiseMap(e) {
        mapboxgl.accessToken = MapHandler.MAP_API;
        e = null !== e ? e : {};
        e.container || (e.container = "map"), e.center || (e.center = [-.1280432939529419, 51.50805967151767]), e.zoom || (e.zoom = 16), e.style = getDefaultImagery(), null === MapHandler.MAP || void 0 === MapHandler.MAP ? (MapHandler.MAP = new mapboxgl.Map(e), MapHandler.MAP_OPTIONS = e, MapHandler.MAP.on("click", e => this.handleClick(e, null)), MapHandler.MAP.on("mousemove", e => this.handleMouse(e)), MapHandler_Mapbox.POPUP = new mapboxgl.Popup({
            closeButton: !1,
            closeOnClick: !1,
            maxWidth: "400px"
        })) : (MapHandler.MAP.setStyle(e.style), delete e.container, MapHandler.MAP.jumpTo(e))
    }
    handleClick(t, a) {
        if (MapHandler.ALLOW_CLICKS) {
            let e = [];
            null != a ? e.push(a) : e = MapHandler.MAP.queryRenderedFeatures(t.point), e = e.filter(e => MapboxUtils.isCMCLLayer(e)), 1 < (e = MapboxUtils.deduplicate(e)).length ? this.clickMultiple(e) : 1 === e.length && (a = e[0], null !== (t = Manager.DATA_STORE.getLayerWithID(a.layer.id).definition.clickable) && !1 === t || (MapboxUtils.isCluster(a) ? this.clickMultiple(e) : this.manager.showFeature(a)))
        }
    }
    async clickMultiple(e) {
        var t, a, n = [],
            i = (await MapboxUtils.recurseFeatures(n, e), window.selectFeatures = {}, {});
        for (let e = 0; e < n.length; e++) {
            var r = n[e],
                l = r.layer.id,
                l = Manager.DATA_STORE.getLayerWithID(l),
                s = l.definition.clickable;
            null !== s && !1 === s || (null !== i[l.name] && void 0 !== i[l.name] || (i[l.name] = []), i[l.name].push(r))
        }
        let o = `
            <p>
                Multiple closely spaced features are located at these coordinates.
                <br/><br/>
                Please choose which individual feature you'd like to select using the drop-down box below.
                Features are grouped by their containing layer.
            </p>
            </br>
            <div id="featureSelectContainer">
                <select name="features" id="featureSelect" onchange="manager.featureSelectChange(this)">
                    <option value="" disabled selected>Select a feature from a layer...</option>
        `;
        for ([t, a] of Object.entries(i)) {
            var d = a;
            o += "<optgroup label='" + t + "'>", d.forEach(e => {
                var t = null !== e.properties.name && void 0 !== e.properties.name ? e.properties.name : "Feature #" + e.id,
                    a = e.layer.id,
                    a = e.id + "@" + a,
                    t = `
                    <option value="` + a + '">' + t + `</option>
                `;
                o += t, window.selectFeatures[a] = e
            }), o += "</optgroup>"
        }
        o += `
                </select>
            </div>
        `, document.getElementById("titleContainer").innerHTML = "<h2>Multiple locations...</h2>", document.getElementById("contentContainer").innerHTML = o
    }
    handleMouse(e) {
        let t = MapHandler.MAP.queryRenderedFeatures(e.point);
        var a, n, i;
        0 === (t = t.filter(e => MapboxUtils.isCMCLLayer(e))).length ? (MapHandler.MAP.getCanvas().style.cursor = "", null !== MapHandler_Mapbox.POPUP && MapHandler_Mapbox.POPUP.remove()) : 0 < t.length && (a = t[0], null !== (i = (n = Manager.DATA_STORE.getLayerWithID(a.layer.id)).definition.clickable) && !1 === i || (MapHandler.MAP.getCanvas().style.cursor = "pointer", null != n && n instanceof MapboxLayer && null !== a && MapboxUtils.showPopup(e, a)))
    }
    plotData(e) {
        let t = [];
        e.dataGroups.forEach(e => {
            e = e.flattenDown();
            t = t.concat(e)
        }), (t = t.sort((e, t) => e.order > t.order ? 1 : e.order < t.order ? -1 : 0)).forEach(e => this.plotLayer(null, e))
    }
    plotLayer(e, t) {
        var a = t.source;
        null != a && (this.addSource(a), this.addLayer(t))
    }
    addSource(e) {
        var t = MapHandler.MAP.getSource(e.id);
        null == t && ((t = {
            ...e.definition
        }).id && delete t.id, t.metaFiles && delete t.metaFiles, t.timeseriesFiles && delete t.timeseriesFiles, "video" === e.type || "image" === e.type || t.attribution || (t.attribution = "CMCL Innovations"), MapHandler.MAP.addSource(e.id, t), console.info("Added source to Mapbox map: " + e.id))
    }
    addLayer(e) {
        var t = MapHandler.MAP.getLayer(e.id);
        null == t && ((t = {
            ...e.definition
        }).metadata || (t.metadata = {}), t.metadata.attribution || (t.metadata.attribution = "CMCL Innovations"), t.clickable ? (t.metadata.clickable = t.clickable, delete t.clickable) : t.metadata.clickable = !0, t.treeable ? (t.metadata.treeable = t.treeable, delete t.treeable) : t.metadata.treeable = !0, t.id = e.id, delete t.name, delete t.order, MapHandler.MAP.addLayer(t), console.info("Added layer to Mapbox map '" + e.id + "'."))
    }
    addIcons(e) {
        return $.getJSON(e, function(e) {
            return e
        }).fail(() => {
            console.warn("Could not read icons.json, skipping.")
        }).done(e => {
            if (null != e) {
                var t, a = [],
                    n = new IconHandler;
                for (t of Object.keys(e)) a.push(n.loadIcon(t, e[t]));
                return Promise.all(a).then(() => {
                    console.info("All images have been registered.")
                })
            }
        })
    }
}
class MapboxLayer extends DataLayer {
    constructor(e, t, a) {
        super(e, t, a)
    }
    isVisible() {
        return void 0 !== MapHandler.MAP.getLayer(this.id) ? "visible" === MapHandler.MAP.getLayoutProperty(this.id, "visibility") : null == this.definition.layout || null == this.definition.layout.visibility || "visible" === this.definition.layout.visibility
    }
}
class SearchHandler_Mapbox extends SearchHandler {
    constructor() {
        super(...arguments), this.previousFilters = {}, this.cachedSources = {}
    }
    turnOffClustering() {
        this.cachedSources = {};
        var e = MapHandler.MAP.getStyle(),
            t = e.sources;
        Object.entries(t).forEach(([e, t]) => {
            t.hasOwnProperty("cluster") && t.cluster && ((this.cachedSources[e] = t).cluster = !1)
        }), MapHandler.MAP.setStyle(e)
    }
    turnOnClustering() {
        var e = MapHandler.MAP.getStyle(),
            t = e.sources;
        Object.entries(t).forEach(([e, t]) => {
            t.hasOwnProperty("cluster") && !1 === t.cluster && this.cachedSources.hasOwnProperty(e) && (t.cluster = !0)
        }), this.cachedSources = {}, MapHandler.MAP.setStyle(e)
    }
    runSearch(t) {
        this.cancelSearch();
        var a = MapHandler.MAP.getStyle().layers;
        for (let e = 0; e < a.length; e++) {
            var n, i, r, l = a[e].metadata;
            null != l && (null != (l = l.attribution) && "CMCL Innovations" === l && (n = a[e].id, i = MapHandler.MAP.getFilter(n), null != (r = this.createFilter(i, t)))) && (this.previousFilters[n] = i, MapHandler.MAP.setFilter(n, r))
        }
    }
    cancelSearch() {
        null != this.previousFilters && (Object.entries(this.previousFilters).forEach(([e, t]) => {
            MapHandler.MAP.setFilter(e, t)
        }), this.previousFilters = {})
    }
    createFilter(e, t) {
        var a = this.property.property;
        let n = null;
        var i = document.getElementById("finderRangeSelect");
        if ("boolean" == typeof t) switch (i.value) {
            case "true":
                n = ["all", ["has", a],
                    ["==", ["to-boolean", ["get", a]], !0]
                ];
                break;
            case "false":
                n = ["all", ["has", a],
                    ["==", ["to-boolean", ["get", a]], !1]
                ]
        } else if (isNaN(t)) {
            if (String(t)) switch (t = t.toLowerCase(), i.value) {
                case "contains":
                    n = ["all", ["has", a],
                        ["in", t, ["downcase", ["get", a]]]
                    ];
                    break;
                case "starts":
                    n = ["all", ["has", a],
                        ["==", ["index-of", t, ["downcase", ["get", a]]], 0]
                    ]
            }
        } else switch (i.value) {
            case "equals":
                n = ["all", ["has", a],
                    ["==", Number(t), ["to-number", ["get", a]]]
                ];
                break;
            case "lesser":
                n = ["all", ["has", a],
                    ["<", ["to-number", ["get", a]], Number(t)]
                ];
                break;
            case "greater":
                n = ["all", ["has", a],
                    [">", ["to-number", ["get", a]], Number(t)]
                ]
        }
        return null === n || void 0 === n ? null : n = null != e ? ["all", e, n] : n
    }
}
class MapboxUtils {
    static isCMCLLayer(e) {
        try {
            var t = e.layer;
            return "none" === MapHandler.MAP.getLayoutProperty(t.id, "visibility") ? !1 : !!t.metadata && !(!t.metadata.attribution || "CMCL Innovations" !== t.metadata.attribution || !t.metadata.clickable)
        } catch (e) {
            return !1
        }
    }
    static showPopup(a, n) {
        if (MapboxUtils.isCluster(n)) MapboxUtils.showClusterPopup(a, n);
        else {
            var n = n.properties,
                i = n.name;
            if (null != i) {
                let e = n.description,
                    t = "";
                null == (e = null === e && n.desc ? n.desc : e) ? t += "<h3 style='text-align: center !important;'>" + i + "</h3>" : (t += "<h3>" + i + "</h3>", 100 < e.length ? t += "<div class='desc-popup long-popup'></br>" + e + "</div>" : t += "<div class='desc-popup'></br>" + e + "</div>"), n.thumbnail && (t = (t += "<br/><br/>") + "<img class='thumbnail' src='" + n.thumbnail + "'>"), MapHandler_Mapbox.POPUP.setLngLat(a.lngLat).setHTML(t).addTo(MapHandler.MAP)
            }
        }
    }
    static showClusterPopup(e, t) {
        t = "<h3>Multiple locations</h3>" + (`
            This feature represents a cluster of ` + t.properties.point_count + ` (or more) closely spaced, individual locations.<br/>Click to see details on the underlying locations.
        `);
        MapHandler_Mapbox.POPUP.setLngLat(e.lngLat).setHTML(t).addTo(MapHandler.MAP)
    }
    static async recurseFeatures(a, n) {
        for (let e = 0; e < n.length; e++) {
            let t = n[e];
            var i;
            MapboxUtils.isCluster(t) ? ((i = await MapboxUtils.getClusterLeaves(t, t.layer.source, 999, 0)).forEach(e => {
                null !== e.layer && void 0 !== e.layer || (e.layer = t.layer)
            }), MapboxUtils.recurseFeatures(a, i)) : a.push(t)
        }
    }
    static async getClusterLeaves(e, t, i, r) {
        let l = MapHandler.MAP.getSource(t);
        return new Promise((a, n) => {
            l.getClusterLeaves(e.id, i, r, (e, t) => {
                e ? n(e) : a(t)
            })
        })
    }
    static isCluster(e) {
        return e.properties.hasOwnProperty("cluster") && e.properties.cluster
    }
    static anyLayersAdded(t) {
        for (let e = 0; e < t.length; e++) {
            var a = t[e];
            if (null != MapHandler.MAP.getLayer(a)) return !0
        }
        return !1
    }
    static anyLayersVisible(t) {
        for (let e = 0; e < t.length; e++) {
            var a = t[e];
            if ("visible" === MapHandler.MAP.getLayoutProperty(a, "visibility")) return !0
        }
        return !1
    }
    static changeTerrain(t) {
        var a = Manager.SETTINGS.getSetting("imagery");
        if (null != a) {
            let e = a[t];
            null != e && (e.endsWith("_token=") && (e += MapHandler.MAP_API), MapHandler.MAP.setStyle(e), window.terrain = t, MapboxUtils.hideBuildings())
        }
    }
    static generateDefaultImagery() {
        var e = {
            Light: "mapbox://styles/mapbox/light-v10?optimize=true",
            Dark: "mapbox://styles/mapbox/dark-v10?optimize=true",
            Outdoors: "mapbox://styles/mapbox/outdoors-v11?optimize=true",
            Satellite: "mapbox://styles/mapbox/satellite-streets-v11?optimize=true",
            default: "Light"
        };
        Manager.SETTINGS.putSetting("imagery", e)
    }
    static hideBuildings() {
        null != MapHandler.MAP && ["building", "building-outline", "building-underground"].forEach(e => {
            null != MapHandler.MAP.getLayer(e) && MapHandler.MAP.setLayoutProperty(e, "visibility", "none")
        })
    }
    static resetCamera() {
        var e = MapHandler.MAP_OPTIONS;
        null != e && MapHandler.MAP.flyTo({
            curve: 1.9,
            speed: 1.6,
            pitch: e.pitch,
            bearing: e.bearing,
            zoom: e.zoom,
            center: e.center
        })
    }
    static setTiltshift(e) {
        var t = document.getElementById("tiltShift");
        null != t && (t.style.display = e ? "block" : "none", e) && (MapHandler.MAP.on("zoom", function() {
            MapboxUtils.updateTiltShift()
        }), MapHandler.MAP.on("pitch", function() {
            MapboxUtils.updateTiltShift()
        }), MapboxUtils.updateTiltShift())
    }
    static updateTiltShift() {
        var e, t, a, n, i = document.getElementById("tiltShift");
        null != i && "block" === i.style.display && (e = "black " + 5 * (a = MapHandler.MAP.getPitch() / 90 * (MapHandler.MAP.getZoom() / 20)) + "%", t = "rgba(0, 0, 0, 0) " + 60 * a + "%", a = "rgba(0, 0, 0, 0) " + (100 - 15 * a) + "%", n = "rgba(0, 0, 0, 0.5) 100%", i.style.backdropFilter = "blur(5px)", i.style.webkitBackdropFilter = "blur(5px)", i.style.webkitMaskImage = "linear-gradient(" + e + ", " + t + ", " + a + ", " + n + ")", i.style.maskImage = "linear-gradient(" + e + ", " + t + ", " + a + ", " + n + ")")
    }
    static set3DTerrain(e) {
        e ? (MapHandler.MAP.addSource("mapbox-3d-terrain", {
            type: "raster-dem",
            url: "mapbox://mapbox.mapbox-terrain-dem-v1",
            tileSize: 512,
            maxzoom: 14
        }), MapHandler.MAP.setTerrain({
            source: "mapbox-3d-terrain",
            exaggeration: 1.5
        })) : (MapHandler.MAP.setTerrain(null), null != MapHandler.MAP.getSource("mapbox-3d-terrain") && MapHandler.MAP.removeSource("mapbox-3d-terrain"))
    }
    static setPlacenames(t) {
        let a = ["road-number-shield", "road-label", "road-intersection", "waterway-label", "natural-line-label", "natural-point-label", "water-line-label", "water-point-label", "poi-label", "airport-label", "settlement-subdivision-label", "settlement-minor-label", "settlement-major-label", "settlement-label", "state-label", "country-label", "road-oneway-arrow-blue", "road-oneway-arrow-white", "transit-label"];
        MapHandler.MAP.getStyle().layers.forEach(e => {
            (a.includes(e.id) || "satellite" === window.terrain && e.id.startsWith("road-")) && MapHandler.MAP.setLayoutProperty(e.id, "visibility", t ? "visible" : "none")
        })
    }
    static toggleLayer(e, t) {
        void 0 === MapHandler.MAP.getLayer(e) || e.endsWith("_cluster") || (MapHandler.MAP.setLayoutProperty(e, "visibility", t ? "visible" : "none"), null != MapHandler.MAP.getLayer(e + "_clickable") && MapHandler.MAP.setLayoutProperty(e + "_clickable", "visibility", t ? "visible" : "none"), null != MapHandler.MAP.getLayer(e + "_cluster") && MapHandler.MAP.setLayoutProperty(e + "_cluster", "visibility", t ? "visible" : "none"), null != MapHandler.MAP.getLayer(e + "_arrows") && MapHandler.MAP.setLayoutProperty(e + "_arrows", "visibility", t ? "visible" : "none"), null != MapHandler.MAP.getLayer(e + "-highlight") && MapHandler.MAP.setLayoutProperty(e + "-highlight", "visibility", t ? "visible" : "none"))
    }
    static deduplicate(e) {
        let n = [];
        return e.forEach(e => {
            let t = e.id;
            var a = n.find(e => e.id === t);
            null == a && n.push(e)
        }), n
    }
    static loadSearchTerms() {
        let e = Manager.SETTINGS.getSetting("search");
        null == e && (e = {
            Name: "name"
        });
        var t, a, n = document.getElementById("search-select");
        for ([t, a] of Object.entries(e)) {
            var i = document.createElement("option");
            i.text = t, i.value = a, n.add(i)
        }
    }
}
class MapHandler_Cesium extends MapHandler {
    constructor(e) {
        super(e)
    }

    initialiseMap(mapOptions) {
        let defaultImagery, imageryProvider;

        MapHandler.MAP_OPTIONS = mapOptions;

        if (!MapHandler.MAP) {
            defaultImagery = getDefaultImagery();

            if (defaultImagery.endsWith("access_token=")) {
                defaultImagery += MapHandler.MAP_API;
            }

            MapHandler.MAP = new Cesium.Viewer("map", {
                timeline: false,
                animation: false,
                baseLayerPicker: false,
                homeButton: false,
                infoBox: false,
                navigationHelpButton: false,
                projectionPicker: false,
                fullscreenButton: false,
                geocoder: false,
                selectionIndicator: false,
                sceneModePicker: false
            });

            MapHandler.MAP.scene.globe.undergroundColor = Cesium.Color.GREY;

            if (mapOptions.hasOwnProperty("opacity")) {
                let opacity = mapOptions.opacity;
                MapHandler.MAP.scene.globe.translucency.enabled = true;
                MapHandler.MAP.scene.globe.translucency.frontFaceAlphaByDistance =
                    new Cesium.NearFarScalar(1000, Math.abs(opacity), 2000, 1);
            }

            MapHandler.MAP.scene.globe.depthTestAgainstTerrain = true;
            MapHandler.MAP.imageryLayers.removeAll(true);

            imageryProvider = new Cesium.UrlTemplateImageryProvider({
                url: defaultImagery,
                credit: "mapbox"
            });
            this.addOPFButton();
            this.addInstantiateKGButton();

            MapHandler.MAP.scene.imageryLayers.addImageryProvider(imageryProvider);

            let cameraController = MapHandler.MAP.scene.screenSpaceCameraController;
            cameraController.tiltEventTypes = [Cesium.CameraEventType.RIGHT_DRAG];
            cameraController.zoomEventTypes = cameraController.zoomEventTypes.filter(
                eventType => eventType !== Cesium.CameraEventType.RIGHT_DRAG
            );

            cameraController._zoomFactor = 2;

            let screenSpaceEventHandler = new Cesium.ScreenSpaceEventHandler(MapHandler.MAP.scene.canvas);
            screenSpaceEventHandler.setInputAction(event => this.handleClick(event), Cesium.ScreenSpaceEventType.LEFT_CLICK);

            CesiumUtils.enableSilhouettes();
            screenSpaceEventHandler.setInputAction(event => this.handleMouse(event), Cesium.ScreenSpaceEventType.MOUSE_MOVE);

            this.updateCameraView(mapOptions);

            CesiumUtils.setupKeyboardShortcuts();
            this.addTerrain();

        } else {
            this.updateCameraView(mapOptions);
        }
    }

    //
    addOPFButton(){
        // To geographically place an HTML element on top of the Cesium canvas, we use
        // scene.cartesianToCanvasCoordinates to map a world position to canvas x and y values.
        // This example places and img element, but any element will work.

        const htmlOverlay = document.getElementById("runOPFButton");
        const scratch = new Cesium.Cartesian2();
        MapHandler.MAP.scene.preRender.addEventListener(function () {
          const position = Cesium.Cartesian3.fromDegrees(103.6886, 1.347888888888889);
          const canvasPosition = MapHandler.MAP.scene.cartesianToCanvasCoordinates(
            position,
            scratch
          );
          if (Cesium.defined(canvasPosition)) {
            htmlOverlay.style.top = `${canvasPosition.y}px`;
            htmlOverlay.style.left = `${canvasPosition.x}px`;
          }
        });

        document.getElementById('runOPFButton').addEventListener('click', function() {
            fetch('http://example.com', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify('data_to_send'),
            })
            .then((response) => response.json())
            .then((data) => {
                console.log('Success:', data);
            })
            .catch((error) => {
                console.error('Error:', error);
            });
        });
    }

    addInstantiateKGButton(){
        // To geographically place an HTML element on top of the Cesium canvas, we use
        // scene.cartesianToCanvasCoordinates to map a world position to canvas x and y values.
        // This example places and img element, but any element will work.

        const htmlOverlay = document.getElementById("instantiateKGButton");
        const scratch = new Cesium.Cartesian2();
        MapHandler.MAP.scene.preRender.addEventListener(function () {
          const position = Cesium.Cartesian3.fromDegrees(103.6986, 1.347888888888889);
          const canvasPosition = MapHandler.MAP.scene.cartesianToCanvasCoordinates(
            position,
            scratch
          );
          if (Cesium.defined(canvasPosition)) {
            htmlOverlay.style.top = `${canvasPosition.y}px`;
            htmlOverlay.style.left = `${canvasPosition.x}px`;
          }
        });

        document.getElementById('instantiateKGButton').addEventListener('click', function() {
            fetch('http://localhost:3838/historical-ntuenergy-agent/retrieve/retrieve?agentProperties=HISTORICALNTUENERGY_AGENTPROPERTIES&xlsxConnectorProperties=HISTORICALNTUENERGY_XLSXCONNECTORPROPERTIES', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                // remove the body option if you don't want to send any data
                // if you do, replace 'data_to_send' with the actual data
                // body: JSON.stringify('data_to_send'),
            })
            .then((response) => response.json())
            .then((data) => {
                console.log('Success:', data);
            })
            .catch((error) => {
                console.error('Error:', error);
            });
        });

    }

    updateCameraView(mapOptions) {
        MapHandler.MAP.camera.setView({
            destination: Cesium.Cartesian3.fromDegrees(mapOptions.center[0], mapOptions.center[1], mapOptions.center[2]),
            orientation: {
                heading: Cesium.Math.toRadians(mapOptions.heading),
                pitch: Cesium.Math.toRadians(mapOptions.pitch),
                roll: Cesium.Math.toRadians(mapOptions.roll)
            }
        });

        MapHandler.MAP.scene.requestRender();
    }

    /**
    initialiseMap(e) {
        var t, a;
        MapHandler.MAP_OPTIONS = e, null === MapHandler.MAP || void 0 === MapHandler.MAP ? ((t = getDefaultImagery()).endsWith("access_token=") && (t += MapHandler.MAP_API), MapHandler.MAP = new Cesium.Viewer("map", {
            timeline: !1,
            animation: !1,
            baseLayerPicker: !1,
            homeButton: !1,
            infoBox: !1,
            navigationHelpButton: !1,
            projectionPicker: !1,
            fullscreenButton: !1,
            geocoder: !1,
            selectionIndicator: !1,
            sceneModePicker: !1
        }), MapHandler.MAP.scene.globe.undergroundColor = Cesium.Color.GREY, e.hasOwnProperty("opacity") && (MapHandler.MAP.scene.globe.translucency.enabled = !0, a = e.opacity, MapHandler.MAP.scene.globe.translucency.frontFaceAlphaByDistance = new Cesium.NearFarScalar(1e3, Math.abs(a), 2e3, 1)), MapHandler.MAP.scene.globe.depthTestAgainstTerrain = !0, MapHandler.MAP.imageryLayers.removeAll(!0), a = new Cesium.UrlTemplateImageryProvider({
            url: t,
            credit: "mapbox"
        }), MapHandler.MAP.scene.imageryLayers.addImageryProvider(a), (t = MapHandler.MAP.scene.screenSpaceCameraController).tiltEventTypes = [Cesium.CameraEventType.RIGHT_DRAG], t.zoomEventTypes = t.zoomEventTypes.filter(e => e !== Cesium.CameraEventType.RIGHT_DRAG), t._zoomFactor = 2, (a = new Cesium.ScreenSpaceEventHandler(MapHandler.MAP.scene.canvas)).setInputAction(e => this.handleClick(e), Cesium.ScreenSpaceEventType.LEFT_CLICK), CesiumUtils.enableSilhouettes(), a.setInputAction(e => this.handleMouse(e), Cesium.ScreenSpaceEventType.MOUSE_MOVE), MapHandler.MAP.camera.setView({
            destination: Cesium.Cartesian3.fromDegrees(e.center[0], e.center[1], e.center[2]),
            orientation: {
                heading: Cesium.Math.toRadians(e.heading),
                pitch: Cesium.Math.toRadians(e.pitch),
                roll: Cesium.Math.toRadians(e.roll)
            }
        }), MapHandler.MAP.scene.requestRender(), CesiumUtils.setupKeyboardShortcuts(), this.addTerrain()) : (MapHandler.MAP.camera.setView({
            destination: Cesium.Cartesian3.fromDegrees(e.center[0], e.center[1], e.center[2]),
            orientation: {
                heading: Cesium.Math.toRadians(e.heading),
                pitch: Cesium.Math.toRadians(e.pitch),
                roll: Cesium.Math.toRadians(e.roll)
            }
        }), MapHandler.MAP.scene.requestRender())
    }
        **/
addTerrain() {
    var e = Manager.SETTINGS.getSetting("terrain");
    null != e && (e = new Cesium.CesiumTerrainProvider(e), MapHandler.MAP.terrainProvider = e)
}

handleClick(i) {
    if (MapHandler.ALLOW_CLICKS) {
        let n = this;

        CesiumUtils.getFeature(i, function(a) {
            if ((window.currentFeature = a) instanceof Cesium.ImageryLayerFeatureInfo) {
                var e = {
                    ...a.data.properties
                };

                n.manager.showFeature(a, e);
                console.log("running this");
            }
            else {
                try{
                    n.manager.showFeature(a, a.id.name)
                    console.log(a.id)
                }
                catch{
                    let t = {};
                    var e = a?.content?.metadata;

                    if (Cesium.defined(e)) {
                        t = {
                            ...e._properties
                        };
                    } else if ("function" == typeof a.getPropertyIds) {
                        if (null != (e = a.getPropertyIds())) {
                            e.forEach(e => {
                                t[e] = a.getProperty(e);
                            });
                        }
                    } else {
                        console.log("here");
                        e = a.content.tile;
                        console.log("TILE");
                        console.log(e);
                    }

                    n.manager.showFeature(a, t);
                    CesiumUtils.setSelectedSilhouette(a, i);
                }
            }
        });
    }
}

/**
    handleClick(i) {
        if (MapHandler.ALLOW_CLICKS) {
            let n = this;
            CesiumUtils.getFeature(i, function(a) {
                if ((window.currentFeature = a) instanceof Cesium.ImageryLayerFeatureInfo) {
                    var e = {
                        ...a.data.properties
                    };
                    n.manager.showFeature(a, e)
                    console.log("running this")
                }

                else{
                    let t = {};
                    var e = a?.content?.metadata;
                    Cesium.defined(e) ? t = {
                        ...e._properties
                    } : "function" == typeof a.getPropertyIds ? null != (e = a.getPropertyIds()) && e.forEach(e => {
                        t[e] = a.getProperty(e)
                    }) : (console.log("here"), e = a.content.tile, console.log("TILE"), console.log(e)), n.manager.showFeature(a, t), CesiumUtils.setSelectedSilhouette(a, i)
                }
            })
        }
    }
**/

    handleMouse(r) {
        if (MapHandler.ALLOW_CLICKS) {
            let i = document.getElementById("cesiumMetaBox");
            i.style.display = "none", CesiumUtils.getFeature(r, function(t) {
                if (t instanceof Cesium.ImageryLayerFeatureInfo) {
                    var a = {
                            ...t.data.properties
                        },
                        n = getName(a);
                    null != n && "" !== n && (i.style.display = "block", i.style.bottom = MapHandler.MAP.canvas.clientHeight - r.endPosition.y + 50 + "px", i.style.left = r.endPosition.x - 100 + "px", i.innerHTML = CesiumUtils.getPopupContent(a))
                } else {
                    let e = {};
                    n = t?.content?.metadata, a = getName(e = Cesium.defined(n) ? {
                        ...n._properties
                    } : e);
                    null != a && "" !== a && (i.style.display = "block", i.style.bottom = MapHandler.MAP.canvas.clientHeight - r.endPosition.y + 50 + "px", i.style.left = r.endPosition.x - 100 + "px", i.innerHTML = CesiumUtils.getPopupContent(e))
                }
            })
        }
    }
    plotData(e) {
        let t = [],
            a = (e.dataGroups.forEach(e => {
                e = e.flattenDown();
                t = t.concat(e)
            }), t.filter(e => "wms" === e.source.type || "geoserver" === e.source.type));
        (a = a.sort((e, t) => e.order > t.order ? 1 : e.order < t.order ? -1 : 0)).forEach(e => this.plotLayer(null, e)), t.filter(e => "wms" !== e.source.type && "geoserver" !== e.source.type).forEach(e => this.plotLayer(null, e))
    }
    plotLayer(e, t) {
        var a = t.source;
        null != a && (this.addSource(a), this.addLayer(t))
    }
    addSource(e) {}
    addLayer(e) {
        var t = e.source.definition,
            a = t.uri;
        switch (null == a && console.error("Cannot plot a data source that has no 'uri' parameter"), t.type.toLowerCase()) {
            case "wms":
            case "geoserver":
                this.addWMS(t, e);
                break;
            case "kml":
                this.addKMLFile(t, e);
                break;
            case "glb":
            case "gltf":
                this.addGLTFFile(t, e);
                break;
            case "tile":
            case "tiles":
                this.addTileset(t, e);
                break;
            default:
                console.warn("Unknown type '" + t.type + "', skipping this data source.")
        }
    }
addKMLFile(e, t) {
    Cesium.KmlDataSource.load(e.uri)
        .then(e => {
            // Set visibility of the data source
            e.show = null == t.definition.visibility || "visible" === t.definition.visibility;
            // Assign layer ID to the data source
            e.layerID = t.id;

            // Add data source to the map
            MapHandler.MAP.dataSources.add(e);

            console.info("Added KML source to map with layer ID: " + t.id);

            if (null === MapHandler_Cesium.DATA_SOURCES[t.id] || void 0 === MapHandler_Cesium.DATA_SOURCES[t.id]) {
                MapHandler_Cesium.DATA_SOURCES[t.id] = [];
            }

            MapHandler_Cesium.DATA_SOURCES[t.id].push(e);

            // Iterate over all entities of the data source
            e.entities.values.forEach(function(entity) {
                // Check if the entity is a polyline
                if (Cesium.defined(entity.polyline)) {
                    // Change the material color of the polyline to red
                    entity.polyline.material = Cesium.Color.MEDIUMSEAGREEN;
                    // Make the polyline thicker
                    entity.polyline.width = 10;
                }
            });
        });
}

    addGLTFFile(e, t) {
        var a = e.position;
        null == a && console.error("Cannot plot a glTF/glB data source that has no 'position' parameter");
        let n = [0, 0, 0];
        e.hasOwnProperty("orientation") && (n = e.orientation);
        a = Cesium.Cartesian3.fromDegrees(a[0], a[1]), a = {
            position: a,
            orientation: Cesium.Transforms.headingPitchRollQuaternion(a, new Cesium.HeadingPitchRoll(n[0], n[1], n[2])),
            model: {
                uri: e.uri,
                scale: e.hasOwnProperty("scale") ? e.scale : 1
            },
            show: null == t.definition.visibility || "visible" === t.definition.visibility
        };
        MapHandler.MAP.entities.add(a), console.info("Added glTF/glB source to map with layer ID: " + t.id), null !== MapHandler_Cesium.DATA_SOURCES[t.id] && void 0 !== MapHandler_Cesium.DATA_SOURCES[t.id] || (MapHandler_Cesium.DATA_SOURCES[t.id] = []), MapHandler_Cesium.DATA_SOURCES[t.id].push(a)
    }

    addTileset(e, t) {
        let a = e.position;
        null !== a && void 0 !== a && (n = Cesium.Cartesian3.fromDegrees(a[0], a[1], a[2]), a = Cesium.Transforms.eastNorthUpToFixedFrame(n));
        var n = e.rotation,
            n = (null != n && void 0 !== n && null != a && (n = new Cesium.HeadingPitchRoll(n[2], n[1], n[0]), n = Cesium.Matrix3.fromHeadingPitchRoll(n, new Cesium.Matrix3), Cesium.Matrix4.multiplyByMatrix3(a, n, a)), {
                url: e.uri,
                show: null == t.definition.visibility || "visible" === t.definition.visibility
            }),
            e = (null !== a && void 0 !== a && (n.modelMatrix = a), new Cesium.Cesium3DTileset(n));

            e.style = new Cesium.Cesium3DTileStyle({
                color: {
                    conditions: [
                        ["${id} === 40", "color('skyblue')"],
                        ["${id} === 442", "color('gold')"],
                        ["${id} === 190", "color('skyblue')"],
                        ["${id} === 120", "color('skyblue')"],
                        ["${id} === 1", "color('skyblue')"],
                        ["${id} === 92", "color('skyblue')"],
                        ["${id} === 47", "color('red')"],
                        ["${id} === 454", "color('red')"],
                        ["${id} === 488", "color('skyblue')"],
                        ["${id} === 17", "color('skyblue')"],
                        ["${id} === 387", "color('red')"],
                        ["${id} === 399", "color('skyblue')"],
                        ["${id} === 277", "color('gold')"],
                        ["true", "color('white')"],
                    ],
                },
            });

        e.layerID = t.id, MapHandler.MAP.scene.primitives.add(e), console.info("Added 3D tileset source to map with layer ID: " + t.id), null !== MapHandler_Cesium.DATA_SOURCES[t.id] && void 0 !== MapHandler_Cesium.DATA_SOURCES[t.id] || (MapHandler_Cesium.DATA_SOURCES[t.id] = []), MapHandler_Cesium.DATA_SOURCES[t.id].push(e)
        //console.error("tile properties:" + JSON.stringify(e.properties)); // You can inspect these properties in your browser's console
    }
    /**
    addTileset(e, t) {
        let a = e.position;
        if (a !== null && a !== undefined) {
            let n = Cesium.Cartesian3.fromDegrees(a[0], a[1], a[2]);
            a = Cesium.Transforms.eastNorthUpToFixedFrame(n);
        }
        var n = e.rotation;
        if (n !== null && n !== undefined && a !== null) {
            n = new Cesium.HeadingPitchRoll(n[2], n[1], n[0]);
            let mat = Cesium.Matrix3.fromHeadingPitchRoll(n, new Cesium.Matrix3);
            a = Cesium.Matrix4.multiplyByMatrix3(a, mat, a);
        }
        var n = {
            url: e.uri,
            show: t.definition.visibility === null || t.definition.visibility === "visible"
        };
        if (a !== null && a !== undefined) {
            n.modelMatrix = a;
        }
        var e = new Cesium.Cesium3DTileset(n);
        e.layerID = t.id;
        e.style = new Cesium.Cesium3DTileStyle({
            color: {
                conditions: [
                    ["${name} === 'Crown Entertainment Complex'", "color('red')"],
                    ["true", "color('white')"],
                ],
            },
        });
        MapHandler.MAP.scene.primitives.add(e);
        console.info("Added 3D tileset source to map with layer ID: " + t.id);
        if (MapHandler_Cesium.DATA_SOURCES[t.id] === null || MapHandler_Cesium.DATA_SOURCES[t.id] === undefined) {
            MapHandler_Cesium.DATA_SOURCES[t.id] = [];
        }
        MapHandler_Cesium.DATA_SOURCES[t.id].push(e);
    }
    **/

    addWMS(e, t) {
        var a = e.wmsLayer,
            n = (null == a && console.error("Cannot plot a WMS data source that has no 'wmsLayer' parameter"), new Cesium.WebMapServiceImageryProvider({
                url: e.uri,
                layers: a,
                parameters: {
                    transparent: !!e.hasOwnProperty("transparency") && e.transparency,
                    format: e.hasOwnProperty("format") ? e.format : "image/png"
                },
                credit: t.id
            })),
            i = (n.layerID = t.id, MapHandler.MAP.imageryLayers);
        i.addImageryProvider(n);
        for (let e = 0; e < i.length; e++) i.get(e).imageryProvider === n && (i.get(e).show = null == t.definition.visibility || "visible" === t.definition.visibility);
        null !== MapHandler_Cesium.DATA_SOURCES[t.id] && void 0 !== MapHandler_Cesium.DATA_SOURCES[t.id] || (MapHandler_Cesium.DATA_SOURCES[t.id] = []), MapHandler_Cesium.DATA_SOURCES[t.id].push(n)
    }
}
MapHandler_Cesium.DATA_SOURCES = {};
class CesiumLayer extends DataLayer {
    constructor(e, t, a) {
        super(e, t, a)
    }
    isVisible() {
        return CesiumUtils.isVisible(this.id)
    }
}
class CesiumUtils {
    static isVisible(e) {
        var t = MapHandler_Cesium.DATA_SOURCES[e];
        if (null == t) return !1;
        for (let e = 0; e < t.length; e++)
            if (!1 === t[e].show) return !1;
        return !0
    }
    static toggleLayer(e, t) {
        var a = MapHandler_Cesium.DATA_SOURCES[e];
        if (null !== a)
            for (let e = 0; e < a.length; e++) {
                var n = a[e];
                if (n instanceof Cesium.WebMapServiceImageryProvider) {
                    var i = MapHandler.MAP.imageryLayers;
                    for (let e = 0; e < i.length; e++) i.get(e).imageryProvider === n && (i.get(e).show = t)
                } else n.show = t
            }
        MapHandler.MAP.scene.requestRender()
    }
    static changeTerrain(a) {
        var n = Manager.SETTINGS.getSetting("imagery");
        if (null != n) {
            let t = null;
            for (let e = 0; e < MapHandler.MAP.imageryLayers.length; e++) {
                var i = MapHandler.MAP.imageryLayers.get(e);
                if (i.isBaseLayer()) {
                    t = i;
                    break
                }
            }
            if (null === t || void 0 === t) console.error("Could not identify base layer!");
            else {
                MapHandler.MAP.imageryLayers.remove(t, !0);
                let e = n[a];
                null != e && (e.endsWith("access_token=") && (e += MapHandler.MAP_API), n = new Cesium.UrlTemplateImageryProvider({
                    url: e,
                    credit: "mapbox"
                }), MapHandler.MAP.scene.imageryLayers.addImageryProvider(n, 0), MapHandler.MAP.scene.requestRender())
            }
        }
    }
    static generateDefaultImagery() {
        var e = {};
        e.Light = "https://api.mapbox.com/styles/v1/mapbox/light-v10/tiles/256/{z}/{x}/{y}?access_token=" + MapHandler.MAP_API, e.Dark = "https://api.mapbox.com/styles/v1/mapbox/dark-v10/tiles/256/{z}/{x}/{y}?access_token=" + MapHandler.MAP_API, e.Outdoors = "https://api.mapbox.com/styles/v1/mapbox/outdoors-v11/tiles/256/{z}/{x}/{y}?access_token=" + MapHandler.MAP_API, e["Satellite (Raw)"] = "https://api.mapbox.com/styles/v1/mapbox/satellite-v9/tiles/256/{z}/{x}/{y}?access_token=" + MapHandler.MAP_API, e["Satellite (Labelled)"] = "https://api.mapbox.com/styles/v1/mapbox/satellite-streets-v11/tiles/256/{z}/{x}/{y}?access_token=" + MapHandler.MAP_API, e.default = "Dark", Manager.SETTINGS.putSetting("imagery", e)
    }
    static resetCamera() {
        var e = MapHandler.MAP_OPTIONS;
        null != e && MapHandler.MAP.camera.flyTo({
            destination: Cesium.Cartesian3.fromDegrees(e.center[0], e.center[1], e.center[2]),
            orientation: {
                heading: Cesium.Math.toRadians(e.heading),
                pitch: Cesium.Math.toRadians(e.pitch),
                roll: Cesium.Math.toRadians(e.roll)
            }
        })
    }
    static enableSilhouettes() {
        if (Cesium.PostProcessStageLibrary.isSilhouetteSupported(MapHandler.MAP.scene)) {
            const t = {
                feature: void 0,
                originalColor: new Cesium.Color
            };
            CesiumUtils.OUTLINE_BLUE = Cesium.PostProcessStageLibrary.createEdgeDetectionStage(), CesiumUtils.OUTLINE_BLUE.uniforms.color = Cesium.Color.CORNFLOWERBLUE, CesiumUtils.OUTLINE_BLUE.uniforms.length = .01, CesiumUtils.OUTLINE_BLUE.selected = [], CesiumUtils.OUTLINE_GREEN = Cesium.PostProcessStageLibrary.createEdgeDetectionStage(), CesiumUtils.OUTLINE_GREEN.uniforms.color = Cesium.Color.MEDIUMSEAGREEN, CesiumUtils.OUTLINE_GREEN.uniforms.length = .01, CesiumUtils.OUTLINE_GREEN.selected = [], MapHandler.MAP.scene.postProcessStages.add(Cesium.PostProcessStageLibrary.createSilhouetteStage([CesiumUtils.OUTLINE_BLUE, CesiumUtils.OUTLINE_GREEN])), MapHandler.MAP.screenSpaceEventHandler.setInputAction(function(e) {
                CesiumUtils.OUTLINE_BLUE.selected = [];
                e = MapHandler.MAP.scene.pick(e.endPosition);
                Cesium.defined(e) && e !== t.feature && (CesiumUtils.OUTLINE_BLUE.selected = [e])
            }, Cesium.ScreenSpaceEventType.MOUSE_MOVE)
        }
    }
    static setSelectedSilhouette(e, t) {
        Cesium.PostProcessStageLibrary.isSilhouetteSupported(MapHandler.MAP.scene) && (CesiumUtils.OUTLINE_GREEN.selected = [], CesiumUtils.OUTLINE_GREEN.selected[0] !== e) && (e === CesiumUtils.OUTLINE_GREEN.selected[0] && (CesiumUtils.OUTLINE_GREEN.selected = []), CesiumUtils.OUTLINE_GREEN.selected = [e])
    }

    //Beautified
    static getFeature(event, callback) {
        if (!callback) throw "Callback function is required!";

        var pickedObject = MapHandler.MAP.scene.pick(event.position || event.endPosition);

        if (pickedObject == null) {
            var pickRay = MapHandler.MAP.camera.getPickRay(event.position || event.endPosition);
            var pickPromise = MapHandler.MAP.imageryLayers.pickImageryLayerFeatures(pickRay, MapHandler.MAP.scene);

            if (Cesium.defined(pickPromise)) {
                Promise.resolve(pickPromise).then(function(pickedFeatures) {
                    if (pickedFeatures.length > 0) {
                        callback(pickedFeatures[0]);
                    }
                });
            }
        } else {
            callback(pickedObject);
        }
    }
    /**
    static getFeature(e, t) {
        if (!t) throw "Callback function is required!";
        var a = MapHandler.MAP.scene.pick(e.position || e.endPosition);
        null == a ? (e = MapHandler.MAP.camera.getPickRay(e.position || e.endPosition), e = MapHandler.MAP.imageryLayers.pickImageryLayerFeatures(e, MapHandler.MAP.scene), Cesium.defined(e) && Promise.resolve(e).then(function(e) {
            0 < e.length && t(e[0])
        })) : t(a)
    }
    **/
    static getPopupContent(e) {
        var t = getName(e),
            a = getDescription(e);
        let n = "";
        return null == a ? n += "<h3 style='text-align: center !important;'>" + t + "</h3>" : (n += "<h3>" + t + "</h3>", 100 < a.length ? n += "<div class='desc-popup long-popup'></br>" + a + "</div>" : n += "<div class='desc-popup'></br>" + a + "</div>"), n = e.thumbnail ? (n += "<br/><br/>") + "<img class='thumbnail' src='" + e.thumbnail + "'>" : n
    }
    static setupKeyboardShortcuts() {
        window.addEventListener("keydown", function(e) {
            if (!e.defaultPrevented) {
                switch (e.key) {
                    case "PageUp":
                        MapHandler.MAP.camera.zoomIn(25);
                        break;
                    case "PageDown":
                        MapHandler.MAP.camera.zoomOut(25);
                        break;
                    default:
                        return
                }
                e.preventDefault()
            }
        }, !0)
    }
    static flyToFeature(e) {
        if (e instanceof Cesium.ImageryLayerFeatureInfo) {
            const a = MapHandler.MAP.scene.globe.ellipsoid.cartographicToCartesian(e.position);
            var t = CesiumUtils.offsetFromHeadingPitchRange(MapHandler.MAP.camera.heading, MapHandler.MAP.camera.pitch, 50);
            const n = Cesium.Transforms.eastNorthUpToFixedFrame(a);
            Cesium.Matrix4.multiplyByPoint(n, t, a), void MapHandler.MAP.camera.flyTo({
                destination: a,
                orientation: {
                    heading: MapHandler.MAP.camera.heading,
                    pitch: MapHandler.MAP.camera.pitch
                },
                easingFunction: Cesium.EasingFunction.QUADRATIC_OUT
            })
        } else if (e.hasOwnProperty("Longitude")) {
            t = new Cesium.Cartographic(Cesium.Math.toRadians(e.getProperty("Longitude")), Cesium.Math.toRadians(e.getProperty("Latitude")), .5 * e.getProperty("Height"));
            const a = MapHandler.MAP.scene.globe.ellipsoid.cartographicToCartesian(t);
            t = CesiumUtils.offsetFromHeadingPitchRange(MapHandler.MAP.camera.heading, MapHandler.MAP.camera.pitch, 2 * e.getProperty("Height"));
            const n = Cesium.Transforms.eastNorthUpToFixedFrame(a);
            Cesium.Matrix4.multiplyByPoint(n, t, a), MapHandler.MAP.camera.flyTo({
                destination: a,
                orientation: {
                    heading: MapHandler.MAP.camera.heading,
                    pitch: MapHandler.MAP.camera.pitch
                },
                easingFunction: Cesium.EasingFunction.QUADRATIC_OUT
            })
        }
    }
    static offsetFromHeadingPitchRange(e, t, a) {
        t = Cesium.Math.clamp(t, -Cesium.Math.PI_OVER_TWO, Cesium.Math.PI_OVER_TWO), e = Cesium.Math.zeroToTwoPi(e) - Cesium.Math.PI_OVER_TWO;
        t = Cesium.Quaternion.fromAxisAngle(Cesium.Cartesian3.UNIT_Y, -t), e = Cesium.Quaternion.fromAxisAngle(Cesium.Cartesian3.UNIT_Z, -e), t = Cesium.Quaternion.multiply(e, t, e), e = Cesium.Matrix3.fromQuaternion(t), t = Cesium.Cartesian3.clone(Cesium.Cartesian3.UNIT_X);
        return Cesium.Matrix3.multiplyByVector(e, t, t), Cesium.Cartesian3.negate(t, t), Cesium.Cartesian3.multiplyByScalar(t, a, t), t
    }
}