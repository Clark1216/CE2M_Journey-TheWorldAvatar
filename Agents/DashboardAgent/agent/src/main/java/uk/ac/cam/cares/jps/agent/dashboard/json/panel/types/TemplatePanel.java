package uk.ac.cam.cares.jps.agent.dashboard.json.panel.types;

import uk.ac.cam.cares.jps.agent.dashboard.utils.StringHelper;

import java.util.Collections;
import java.util.Comparator;
import java.util.List;

/**
 * A Java representation of a JSON-like model that encapsulates and enforces information about template panel syntax
 * specific to Grafana dashboard. This is a super class that is intended to be implemented by the subclass, and only provide common syntax.
 *
 * @author qhouyee
 */
public abstract class TemplatePanel {
    private final String MEASURE;
    private String TITLE;
    private String DESCRIPTION;
    private String UNIT = "null";
    private final String DATABASE_CONNECTION_ID;
    private StringBuilder QUERY_SYNTAX = new StringBuilder();
    protected final TransformationOptions TRANSFORMATIONS;

    /**
     * A constructor that sets up common aspects of the panels.
     *
     * @param measure            The measure name for this variable.
     * @param itemGroup          The item group for this measure - asset type or rooms.
     * @param databaseId         The database connection ID generated by Grafana.
     * @param timeSeriesMetadata A list of assets and their metadata for the specified measure.
     */
    protected TemplatePanel(String measure, String itemGroup, String databaseId, List<String[]> timeSeriesMetadata) {
        this(measure, databaseId);
        // Create the query syntax from the parameters
        // Assumes that each measure of a specific item group belongs to only 1 table
        String tableName = timeSeriesMetadata.get(0)[2];
        this.QUERY_SYNTAX.append("SELECT time AS \\\"time\\\", ${")
                // Custom csv parameter must be lower case with no spacing ie: measurenameitemgroup
                .append(StringHelper.formatVariableName(measure)).append(StringHelper.formatVariableName(itemGroup)).append(":csv} ")
                .append("FROM \\\"").append(tableName).append("\\\" WHERE $__timeFilter(time)");
        this.TRANSFORMATIONS.addOrganizeTransformation(timeSeriesMetadata);
    }

    /**
     * A constructor that initialises the measure and database connection ID, but requires users to set the query and transformation options.
     *
     * @param measure    The measure name for this variable.
     * @param databaseId The database connection ID generated by Grafana.
     */
    protected TemplatePanel(String measure, String databaseId) {
        this.MEASURE = measure;
        this.DATABASE_CONNECTION_ID = databaseId;
        this.TRANSFORMATIONS = new TransformationOptions();
    }

    /**
     * Gets the measure of this panel.
     */
    public String getMeasure() {
        return this.MEASURE;
    }

    public String getUnit() {
        return this.UNIT;
    }

    public void setUnit(String unit) {
        this.UNIT = unit;
    }

    /**
     * Sets the title.
     */
    protected void setTitle(String title) {
        this.TITLE = title;
    }

    /**
     * Sets the description.
     */
    protected void setDescription(String description) {
        this.DESCRIPTION = description;
    }

    /**
     * Sets the query syntax.
     */
    protected void setQuery(StringBuilder query) {
        this.QUERY_SYNTAX = query;
    }

    /**
     * Construct the common JSON parts for panel as a StringBuilder which will continue to append specific syntax for different query types.
     *
     * @return The variable syntax as a StringBuilder.
     */
    protected StringBuilder genCommonJson(int height, int width, int xPosition, int yPosition) {
        verifyVariable(this.TITLE, "Title");
        verifyVariable(this.DESCRIPTION, "Description");
        StringBuilder builder = new StringBuilder();
        builder.append("\"id\": null,") // Generate a new ID for this panel
                // Title of this panel
                .append("\"title\": \"").append(this.TITLE).append("\",")
                // Description for this panel
                .append("\"description\": \"").append(this.DESCRIPTION).append("\",")
                // Postgres datasource
                .append("\"datasource\": {\"type\": \"postgres\", \"uid\": \"").append(this.DATABASE_CONNECTION_ID).append("\"},")
                // Targets the written queries with their configuration to execute and retrieve data
                .append("\"targets\": [{\"datasource\":{\"type\":\"postgres\",\"uid\":\"").append(this.DATABASE_CONNECTION_ID) // Ensure data source is postgres
                // Query configurations
                .append("\"}, \"editorMode\":\"code\",\"format\":\"table\",\"rawQuery\":true,\"refId\":\"A\",")
                .append("\"sql\":{\"columns\": [{\"parameters\": [],\"type\":\"function\"}], \"groupBy\": [{\"property\":{\"type\":\"string\"},\"type\":\"groupBy\"}],\"limit\":50},")
                // Query to be executed
                .append("\"rawSql\":\"").append(this.QUERY_SYNTAX).append("\"}],")
                // Grid position: Two panels of height:4 and width:6 will be found at (0,0), (6,4) coordinates
                // Height and width are dimensions of the panel
                .append("\"gridPos\":{\"h\":").append(height).append(",\"w\":").append(width)
                // x and y are the placement position within the dashboard/grid
                .append(",\"x\":").append(xPosition).append(",\"y\":").append(yPosition).append("},")
                .append("\"transformations\":").append(this.TRANSFORMATIONS.construct());
        return builder;
    }

    /**
     * An abstract method to construct the variable syntax required. This method must be overridden to be executed in the implemented classes.
     */
    public abstract String construct(int height, int width, int xPosition, int yPosition);

    /**
     * Verifies if the mandatory variable exists.
     *
     * @throws NullPointerException when variable is empty.
     */
    private void verifyVariable(String variable, String varType) {
        if (variable == null) {
            throw new NullPointerException(varType + " has not yet been set or is empty!");
        }
    }
}
