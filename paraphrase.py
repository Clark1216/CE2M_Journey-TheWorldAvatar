import argparse
import csv
import json
import os
from typing import List

import openai
from tqdm import tqdm
import pandas as pd

PARAPHRASE_NUM = 3
HEADER = ["id", "verbalization", "paraphrases"]


def sanitize_bulletpoint(text: str):
    text = text.strip()

    if len(text) == 0:
        return text

    if text.startswith("-"):
        text = text[1:]
    elif text[0].isdigit():
        idx = 0
        while idx < len(text) and text[idx].isdigit():
            idx += 1
        text = text[idx:]
        text = text.strip()
        if text[0] in [".", ")"]:
            text = text[1:]

    text = text.strip()

    if text.startswith('"'):
        text = text[1:]
    if text.endswith('"'):
        text = text[:-1]

    return text


def is_bulleted_line(line: str):
    line = line.strip()
    return line.startswith("-") or (len(line) > 0 and line[0].isdigit())


def remove_opening_and_closing_statements(lines: List[str]):
    """Detects and removes opening and closing statements generated by OpenAI, if any.

    Example of an opening statement: "Certainly, here are 10 paraphrased versions of the statement:"

    Example of a closing statement: "Note: In the original statement, "enlist" is used, but it is
    unclear whether it refers to including them in a list or recruiting them for a specific purpose.
    Therefore, the paraphrases provided focus on the understanding that a list of molecules exhibiting
    specific characteristics is being requested."
    """
    if len(lines) > 1 and not is_bulleted_line(lines[0]) and is_bulleted_line(lines[1]):
        lines = lines[1:]

    if (
        len(lines) > 1
        and not is_bulleted_line(lines[-1])
        and is_bulleted_line(lines[-2])
    ):
        lines = lines[:-1]

    return lines


def parse_openai_paraphrase_response_content(content: str):
    lines = [x.strip() for x in content.split("\n")]
    lines = [x for x in lines if x]
    lines = remove_opening_and_closing_statements(lines)
    lines = [sanitize_bulletpoint(x) for x in lines]
    return lines


def get_paraphrases(datum: dict):
    verbalization: str = datum["verbalization"]

    entity_placeholders = ["methanol", "ethanol", "propanol", "butanol", "pentanol"]
    entity_actuals = []

    while True:
        idx_entity_start = verbalization.find("<entity>")
        if idx_entity_start < 0:
            break

        idx_entity_end = verbalization.find("</entity>", idx_entity_start)
        if idx_entity_end < 0:
            raise ValueError("Missing closing entity tag: " + datum)
        idx_entity_end += len("</entity>")

        entity = verbalization[idx_entity_start:idx_entity_end]
        verbalization = verbalization.replace(
            entity, entity_placeholders[len(entity_actuals)]
        )
        entity_actuals.append(entity)

    def helper():
        response = openai.ChatCompletion.create(
            model="gpt-4-0613",
            messages=[
                {
                    "role": "system",
                    "content": "You will be provided with a machine-generated statement. Rephrase it in {num} different ways as if it were human input to a search engine. Make sure that the paraphrases vary in their query structures, terminological expressions, and sentence lengths. Additionally, keep the square brackets and their enclosing text unchanged.".format(
                        num=PARAPHRASE_NUM
                    ),
                },
                {
                    "role": "user",
                    "content": verbalization,
                },
            ],
            temperature=0.5,
            frequency_penalty=1,
        )

        response_content = response["choices"][0]["message"]["content"]
        return parse_openai_paraphrase_response_content(response_content)

    try_limit = 3
    try_num = 0
    paraphrases = None

    while try_num < try_limit:
        if try_num > 0:
            print("Try {num} (started from 0)".format(num=try_num))

        paraphrases = helper()

        if len(paraphrases) != PARAPHRASE_NUM:
            try_num += 1
            continue

        if len(entity_actuals) == 0:  # no placeholders to replace
            break

        will_retry = False
        for i in range(len(paraphrases)):
            for placeholder, actual in zip(entity_placeholders, entity_actuals):
                paraphrase = paraphrases[i].replace(placeholder, actual)
                if paraphrase == paraphrases[i]:
                    will_retry = True
                    break
                paraphrases[i] = paraphrase
            if will_retry:
                break

        if will_retry:
            try_num += 1
            continue
        else:
            break

    if try_num == try_limit:
        raise Exception("Unacceptable paraphrasing results: " + paraphrases)

    if len(paraphrases) != PARAPHRASE_NUM:
        raise Exception(
            "id: {id};\nverbalization: {verbalization};\nparaphrase_num: {paraphrase_num}\nparaphrases: {paraphrases}".format(
                id=datum["id"],
                verbalization=datum["verbalization"],
                paraphrase_num=len(paraphrases),
                paraphrases="\n".join(paraphrases),
            )
        )

    return paraphrases


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("filepath")
    args = parser.parse_args()

    with open(args.filepath, "r") as f:
        data = json.load(f)

    filepath_out = args.filepath.rsplit(".")[0] + "_paraphrases.csv"
    if not os.path.exists(filepath_out):
        f = open(filepath_out, "w")
        writer = csv.writer(f)
        writer.writerow(HEADER)
    else:
        df = pd.read_csv(filepath_out)
        data = [datum for datum in data if datum["id"] not in df["id"]]

        f = open(filepath_out, "a")
        writer = csv.writer(f)

    try:
        for i, datum in enumerate(tqdm(data)):
            paraphrases = get_paraphrases(datum)
            writer.writerow([datum["id"], datum["verbalization"], paraphrases])
    except Exception as e:
        f.close()
        raise e
