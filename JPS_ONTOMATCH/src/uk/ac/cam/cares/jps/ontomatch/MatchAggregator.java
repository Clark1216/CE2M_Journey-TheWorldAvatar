package uk.ac.cam.cares.jps.ontomatch;

import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.BadRequestException;

import org.apache.jena.ontology.Individual;
import org.apache.jena.ontology.OntClass;
import org.apache.jena.ontology.OntModel;
import org.apache.jena.query.ResultSet;
import org.apache.jena.rdf.model.ModelFactory;
import org.apache.jena.util.iterator.ExtendedIterator;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import uk.ac.cam.cares.jps.base.agent.JPSAgent;
import uk.ac.cam.cares.jps.base.annotate.MetaDataAnnotator;
import uk.ac.cam.cares.jps.base.query.JenaHelper;
import uk.ac.cam.cares.jps.base.query.JenaResultSetFormatter;
import uk.ac.cam.cares.jps.base.scenario.JPSHttpServlet;
/***
 * 

Agent that processes all alignment files produced by single metric matching to a combination result
Include functions to choose: weighted sum, filtering ,cardinality filtering, class type penalizing
Must start with weighted sum and end with filtering
Input: IRI of alignments
Output: IRI of new alignmnent
 * @author shaocong
 *
 */
import uk.ac.cam.cares.jps.base.util.AsyncPythonHelper;

/***
 * 
 * Aggregates element level alignment result(tmp alignment owl files). Contains
 * several function to be composed by choice. Input from KG: alignment owl IRIs.
 * Output to KG: result alignment owl IRI.
 * 
 * @author shaocong zhang
 * @version 1.0
 * @since 2020-09-08
 */
@WebServlet(urlPatterns = { "/matchAggregator" })

public class MatchAggregator extends JPSAgent {

	private static final long serialVersionUID = -1142445270131640156L;
	protected String srcOnto, tgtOnto;
	protected String thisAlignmentIRI;
	protected List<List> matchScoreLists = new ArrayList<List>();
	protected List<Map> finalScoreList = new ArrayList<Map>();
	protected List<Double> weights = new ArrayList<Double>();
	protected double threshold;
	protected List<AGGREGATE_CHOICE> choices = new ArrayList<AGGREGATE_CHOICE>();
	protected String classAlignmentIRI;
	protected double pFactor, sameClassThreshold;

	/*** types of optional steps in aggregator **/
	public enum AGGREGATE_CHOICE {
		PENALIZING, CARDINALITY
	}

	public JSONObject processRequestParameters(JSONObject requestParams, HttpServletRequest request) {
		JSONObject jo = requestParams;

		try {
			threshold = jo.getFloat("threshold");
			srcOnto = jo.getString("srcOnto");
			tgtOnto = jo.getString("tgtOnto");
			thisAlignmentIRI = jo.getString("addr");

			/*** get weights *****/
			JSONArray jweight = jo.getJSONArray("weights");
			for (int i = 0; i < jweight.length(); i++) {
				weights.add(jweight.getDouble(i));
			}
			/** get alignment IRIS generated by single matchers ****/
			JSONArray jalignments = jo.getJSONArray("alignments");
			for (int i = 0; i < jalignments.length(); i++) {
				String aIRI = jalignments.getString(i);
				getAlignmentList(aIRI);
			}
			/** get optional steps chosen by caller agent ****/
			if (jo.has("choices")) {
				JSONArray functionChoice = jo.getJSONArray("choices");
				for (int i = 0; i < functionChoice.length(); i++) {
					choices.add(AGGREGATE_CHOICE.valueOf(functionChoice.getString(i)));
				}
			}
		} catch (Exception e1) {
			e1.printStackTrace();
		}

		JSONObject resultObj = new JSONObject();

		/*** reading params for optional step, if any ****/
		try {
			classAlignmentIRI = jo.getString("classAlign");
			pFactor = jo.getInt("pFactor");
			sameClassThreshold = jo.getInt("sameClassThreshold");
		} catch (Exception e) {
			// do nothing as these are optional params
		}
		;
		/*** execute aggregating procedure ****/
		try {
			// run aggregation according to choices of steps
			handleChoice();
			// write result to KG
			AlignmentIOHelper.writeAlignment2File(finalScoreList, srcOnto, tgtOnto, thisAlignmentIRI);
			String successFlag = OntomatchProperties.getInstance().getProperty(OntomatchProperties.SUCCESS_FLAG);
			resultObj.put(successFlag, true);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return resultObj;
	}

	/***
	 * run aggregation according to choices of steps
	 * 
	 * @throws Exception
	 */
	public void handleChoice() throws Exception {
		/***** weighted sum **************/
		weighting();
		/******** cardinality filtering(optional) ****************/
		if (choices != null && choices.contains(AGGREGATE_CHOICE.CARDINALITY)) {
			one2oneCardinalityFiltering();
		}
		/******** class penalizing filtering(optional) ****************/
		if (choices != null && choices.contains(AGGREGATE_CHOICE.PENALIZING)) {
			penalizing(classAlignmentIRI, sameClassThreshold, pFactor);
		}
		/******** filtering by measure value ****************/

		filtering(threshold);
	}

	/***
	 * read alignment from KG and store
	 * 
	 * @param iriOfAlignmentFile
	 */
	public void getAlignmentList(String iriOfAlignmentFile) {
		String queryStr = "PREFIX alignment: <http://knowledgeweb.semanticweb.org/heterogeneity/alignment#> "
				+ "SELECT ?entity1 ?entity2 ?measure " + "WHERE {?cell alignment:entity1 ?entity1."
				+ "?cell  alignment:entity2 ?entity2 ." + "?cell alignment:measure ?measure." + "}";
		List<String[]> resultListfromquery = null;
		try {
			OntModel model = JenaHelper.createModel(iriOfAlignmentFile);
			ResultSet resultSet = JenaHelper.query(model, queryStr);
			String result = JenaResultSetFormatter.convertToJSONW3CStandard(resultSet);
			String[] keys = JenaResultSetFormatter.getKeys(result);
			resultListfromquery = JenaResultSetFormatter.convertToListofStringArrays(result, keys);

		} catch (Exception e) {
			StringWriter sw = new StringWriter();
			e.printStackTrace(new PrintWriter(sw));
			String exceptionAsString = sw.toString();
			//logger.error(exceptionAsString);
		}
		matchScoreLists.add(resultListfromquery);
	}

	/***
	 * weighted sum
	 */
	protected void weighting() {
		int matcherNum = matchScoreLists.size();
		for (int idxMatcher = 0; idxMatcher < matcherNum; idxMatcher++) {
			List aScoreList = matchScoreLists.get(idxMatcher);
			double myWeight = weights.get(idxMatcher);
			int elementNum = matchScoreLists.get(0).size();
			for (int idxElement = 0; idxElement < elementNum; idxElement++) {
				String[] myscore = (String[]) aScoreList.get(idxElement);
				if (idxElement >= finalScoreList.size()) {// index not exists, initiates
					Map<String, Object> acell = new HashMap<>();
					acell.put("entity1", myscore[0]);
					acell.put("entity2", myscore[1]);
					acell.put("measure", Double.parseDouble(myscore[2]) * myWeight);
					finalScoreList.add(acell);
				} else {// index exists, update measure
					Map mcell = finalScoreList.get(idxElement);
					mcell.put("measure", (double) mcell.get("measure") + Double.parseDouble(myscore[2]) * myWeight);
				}
			}
		}
	}

	/***
	 * filtering by measure
	 * 
	 * @param threshold of measure, smaller than this will be discard
	 */
	protected void filtering(double threshold) {// remove cellmaps with measure<threshold
		int elementNum = finalScoreList.size();
		// loop thru cells to filter out based on measurement
		Iterator<Map> it = finalScoreList.iterator();
		while (it.hasNext()) {
			Map mcell = it.next();
			// Do something
			if ((double) mcell.get("measure") - threshold < 0) {
				// TODO:ERR HERE
				it.remove();
			}
		}
	}

	/***
	 * Penalizing measurement based on if two entities belong to same
	 * Class(equivalent class also counts)
	 * 
	 * @param classAlignmentIRI  IRI of the T-BOX matching
	 * @param sameClassThreshold threshold of measurement to determine if two terms
	 *                           in T-BOX is equivalent
	 * @param pFactor            penalizing factor(0<r<1), if not same class,
	 *                           current measure score multiply this factor
	 * @throws Exception
	 */
	protected void penalizing(String classAlignmentIRI, double sameClassThreshold, double pFactor) throws Exception {
		OntModel srcModel = ModelFactory.createOntologyModel();
		srcModel.read(srcOnto);
		OntModel tgtModel = ModelFactory.createOntologyModel();
		tgtModel.read(tgtOnto);
		Map ICMap1 = constructICMap(srcModel, srcOnto);
		Map ICMap2 = constructICMap(tgtModel, tgtOnto);
		int elementNum = finalScoreList.size();
		for (int idxElement = 0; idxElement < elementNum; idxElement++) {
			Map mcell = finalScoreList.get(idxElement);
			String indi1 = (String) mcell.get("entity1");
			String indi2 = (String) mcell.get("entity2");
			JSONArray joca = AlignmentIOHelper.readAlignmentFileAsJSONArray(classAlignmentIRI, sameClassThreshold);
			List classAlign = AlignmentIOHelper.Json2ScoreList(joca);
			if (!sameClass(classAlign, ICMap1, ICMap2, indi1, indi2)) {// does not belong to same class
				mcell.put("measure", (double) mcell.get("measure") * pFactor);// penalize
			}
		}

	}

	/**
	 * Determine if two individual entities from two A-Boxs belongs to equivalent
	 * class
	 * 
	 * @param classAlign List of the class aligned pairs
	 * @param icmap1     individual-class map of ontology1
	 * @param icmap2     individual-class map of ontology2
	 * @param indiIri1   IRI of entity1
	 * @param indiIri2   IRI of entity2
	 * @return boolean belongs to equivalent class or not
	 */
	protected boolean sameClass(List<Map> classAlign, Map icmap1, Map icmap2, String indiIri1, String indiIri2) {
		String class1 = (String) icmap1.get(indiIri1);
		String class2 = (String) icmap1.get(indiIri2);
		if (sameClass(classAlign, class1, class2)) {
			return true;
		} else {
			return false;
		}

	}

	/**
	 * Determine if two classes from two T-Boxs are equivalent
	 * 
	 * @param classAlign List of the class aligned pairs
	 * @param classIRI1  IRI of class1
	 * @param classIRI2  IRI of class2
	 * @return boolean same class or not
	 */
	protected boolean sameClass(List<Map> classAlign, String classIRI1, String classIRI2) {
		for (Map map : classAlign) {
			String mapped1 = (String) map.get("entity1");
			String mapped2 = (String) map.get("entity2");

			if (mapped1.equals(classIRI1) && mapped2.equals(classIRI2)
					|| (mapped1.equals(classIRI2) && mapped2.equals(classIRI1))) {
				return true;
			}
		}
		return false;
	}

	/***
	 * Construct a Individual-class map by querying a ontology model
	 * 
	 * @param model        jena model of the ontology
	 * @param ontologyIRI, IRI of the ontology
	 * @return
	 */
	protected Map constructICMap(OntModel model, String ontologyIRI) {
		Map ICMap = new HashMap();
		ExtendedIterator classes = model.listClasses();
		while (classes.hasNext()) {
			OntClass thisClass = (OntClass) classes.next();
			ExtendedIterator instances = thisClass.listInstances();
			while (instances.hasNext()) {
				Individual thisInstance = (Individual) instances.next();
				ICMap.put(thisInstance.toString(), thisClass.toString());
			}
		}
		return ICMap;
	}

	/***
	 * one-to-one cardinality filtering
	 * 
	 * @throws IOException
	 */
	protected void one2oneCardinalityFiltering() throws IOException {
		// need to call the python for now
		// input: map rendered as json
		String tmpAddress = OntomatchProperties.getInstance().getProperty(OntomatchProperties.CARDINALITYFILTERING_TMP_ALIGNMENT_PATH);
		 AlignmentIOHelper.writeAlignment2File(finalScoreList, srcOnto, tgtOnto, tmpAddress);
		String[] paras = {srcOnto, tgtOnto, tmpAddress};
		String pyName = OntomatchProperties.getInstance().getProperty(OntomatchProperties.PY_NAME_ONETOONECARDI);
		String[] results = AsyncPythonHelper.callPython(pyName, paras, MatchAggregator.class);
		JSONArray scoreListNew = new JSONArray(results[0]);
		finalScoreList = AlignmentIOHelper.Json2ScoreList(scoreListNew);
	}
    @Override
    public boolean validateInput(JSONObject requestParams) throws BadRequestException {
        if (requestParams.isEmpty()||!requestParams.has("threshold")||!requestParams.has("srcOnto")||!requestParams.has("tgtOnto")||!requestParams.has("alignments")||!requestParams.has("addr")) {
            throw new BadRequestException();
        }
        return true;
    }
}
